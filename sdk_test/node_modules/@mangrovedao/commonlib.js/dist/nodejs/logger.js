"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.format = exports.logdataLimiter = exports.createLogger = void 0;
const logform_1 = require("logform");
Object.defineProperty(exports, "format", { enumerable: true, get: function () { return logform_1.format; } });
const json_truncate_1 = __importDefault(require("json-truncate"));
const loglevel_1 = __importDefault(require("loglevel"));
const triple_beam_1 = require("triple-beam");
// These are loglevel's levels
const levels = {
    trace: 0,
    debug: 1,
    info: 2,
    warn: 3,
    error: 4,
    silent: 5,
};
const createLogger = (consoleFormatLogger, logLevel) => {
    /* Expose winston-style interface to the logger */
    // generate fresh logger
    const logger = loglevel_1.default.getLogger(Symbol());
    // remember default log method generator
    var originalFactory = logger.methodFactory;
    // configure colorizer
    const opts = {
        colors: {
            error: "red",
            debug: "blue",
            warn: "yellow",
            data: "grey",
            info: "green",
            verbose: "cyan",
            silly: "magenta",
            custom: "yellow",
        },
    };
    const colorizer = logform_1.format.colorize(opts);
    // generate new logging methods
    logger.methodFactory = function (methodName, logLevel, loggerName) {
        // remember default log method
        var rawMethod = originalFactory(methodName, logLevel, loggerName);
        // create formatter with logform
        const thisFormat = logform_1.format.combine(colorizer, logform_1.format.splat(), logform_1.format.timestamp(), logform_1.format.errors({ stack: true }), consoleFormatLogger);
        // generate actual logging method
        return function (message, metadata) {
            // send log info to formatter
            const formatted = thisFormat.transform({
                // convert to logLevel string, since that is what logform expects
                level: methodName,
                [triple_beam_1.LEVEL]: methodName,
                message,
                ...metadata,
            });
            if (typeof formatted != "boolean") {
                // retrieve formatted message, send to raw method
                rawMethod(formatted[triple_beam_1.MESSAGE]);
            }
        };
    };
    // simultaneously set logger level as low as possible & apply new methodFactory.
    const logLevelNum = levels[logLevel.toLowerCase()];
    if (logLevelNum === undefined) {
        throw Error(`Unknown logLevel: ${logLevel}`);
    }
    logger.setLevel(logLevelNum);
    return logger;
};
exports.createLogger = createLogger;
// This processor must be used when logging large objects, because of Winston memory consumption in that case
const logdataLimiter = (data) => {
    return (0, json_truncate_1.default)(data, { maxDepth: 3, replace: "[Truncated]" });
};
exports.logdataLimiter = logdataLimiter;
exports.default = exports.createLogger;
//# sourceMappingURL=logger.js.map
"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Semibook_instances, _Semibook_offer_gasbase, _Semibook_canInitialize, _Semibook_blockEventCallback, _Semibook_eventFilter, _Semibook_eventListener, _Semibook_logQueue, _Semibook_cacheLock, _Semibook_offerCache, _Semibook_bestInCache, _Semibook_worstInCache, _Semibook_lastReadBlockNumber, _Semibook_foldLeftUntil, _Semibook_foldLeftUntilInCache, _Semibook_initialize, _Semibook_handleBookEventFromProvider, _Semibook_handleBookEvents, _Semibook_handleBookEvent, _Semibook_insertOffer, _Semibook_removeOffer, _Semibook_fetchOfferListPrefix, _Semibook_fetchOfferListPrefixUntil, _Semibook_rawLocalConfigToLocalConfig, _Semibook_idToRawId, _Semibook_createEventFilter, _Semibook_setDefaultsAndValidateOptions, _CacheIterator_offerCache, _CacheIterator_latest, _CacheIterator_predicate;
Object.defineProperty(exports, "__esModule", { value: true });
const async_mutex_1 = require("async-mutex");
const big_js_1 = require("big.js");
const ethers_1 = require("ethers");
const _1 = require(".");
const trade_1 = __importDefault(require("./util/trade"));
const unitCalculations_1 = __importDefault(require("./util/unitCalculations"));
// Guard constructor against external calls
let canConstructSemibook = false;
/**
 * The Semibook is a data structure for maintaining a cached prefix
 * of an offer list for one side (asks or bids) of a market.
 *
 * While offer lists on-chain for a market A-B are symmetric (the offer lists are
 * the same for the market B-A), a `Semibook` depends on the market:
 *
 * - Prices are in terms of quote tokens
 * - Volumes are in terms of base tokens
 */
// TODO: Document invariants
class Semibook {
    constructor(market, ba, eventListener, options) {
        _Semibook_instances.add(this);
        // TODO: Why is only the gasbase stored as part of the semibook? Why not the rest of the local configuration?
        _Semibook_offer_gasbase.set(this, void 0);
        _Semibook_canInitialize.set(this, void 0); // Guard against multiple initialization calls
        _Semibook_blockEventCallback.set(this, void 0);
        _Semibook_eventFilter.set(this, void 0);
        _Semibook_eventListener.set(this, void 0);
        _Semibook_logQueue.set(this, []);
        _Semibook_cacheLock.set(this, void 0); // Lock that must be acquired when modifying the cache to ensure consistency and to queue cache updating events.
        _Semibook_offerCache.set(this, void 0); // NB: Modify only via #insertOffer and #removeOffer to ensure cache consistency
        _Semibook_bestInCache.set(this, void 0); // id of the best/first offer in the offer list iff #offerCache is non-empty
        _Semibook_worstInCache.set(this, void 0); // id of the worst/last offer in #offerCache
        _Semibook_lastReadBlockNumber.set(this, void 0); // the block number that the cache is consistent with
        this.tradeManagement = new trade_1.default();
        if (!canConstructSemibook) {
            throw Error("Mangrove Semibook must be initialized async with Semibook.connect (constructors cannot be async)");
        }
        this.options = __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_setDefaultsAndValidateOptions).call(this, options);
        this.market = market;
        this.ba = ba;
        __classPrivateFieldSet(this, _Semibook_canInitialize, true, "f");
        __classPrivateFieldSet(this, _Semibook_cacheLock, new async_mutex_1.Mutex(), "f");
        __classPrivateFieldSet(this, _Semibook_eventListener, eventListener, "f");
        __classPrivateFieldSet(this, _Semibook_eventFilter, __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_createEventFilter).call(this), "f");
        __classPrivateFieldSet(this, _Semibook_offerCache, new Map(), "f");
    }
    static async connect(market, ba, eventListener, options) {
        canConstructSemibook = true;
        const semibook = new Semibook(market, ba, eventListener, options);
        canConstructSemibook = false;
        await __classPrivateFieldGet(semibook, _Semibook_instances, "m", _Semibook_initialize).call(semibook);
        return semibook;
    }
    /** Stop listening to events from mangrove */
    disconnect() {
        this.market.mgv.provider.off("block", __classPrivateFieldGet(this, _Semibook_blockEventCallback, "f"));
    }
    async requestOfferListPrefix(options) {
        return await __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_fetchOfferListPrefix).call(this, await this.market.mgv.provider.getBlockNumber(), undefined, // Start from best offer
        options);
    }
    /** Returns struct containing offer details in the current offer list */
    async offerInfo(offerId) {
        const cachedOffer = __classPrivateFieldGet(this, _Semibook_offerCache, "f").get(offerId);
        if (cachedOffer !== undefined) {
            return cachedOffer;
        }
        const { outbound_tkn, inbound_tkn } = this.market.getOutboundInbound(this.ba);
        const [offer, details] = await this.market.mgv.contract.offerInfo(outbound_tkn.address, inbound_tkn.address, offerId);
        return {
            next: Semibook.rawIdToId(offer.next),
            offer_gasbase: details.offer_gasbase.toNumber(),
            ...this.tradeManagement.tradeEventManagement.rawOfferToOffer(this.market, this.ba, {
                id: __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_idToRawId).call(this, offerId),
                ...offer,
                ...details,
            }),
        };
    }
    /**
     * Return config local to a semibook.
     * Notes:
     * Amounts are converted to plain numbers.
     * density is converted to public token units per gas used
     * fee *remains* in basis points of the token being bought
     */
    async getConfig(blockNumber) {
        const rawConfig = await this.getRawConfig(blockNumber);
        return __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_rawLocalConfigToLocalConfig).call(this, rawConfig.local);
    }
    async getRawConfig(blockNumber) {
        const { outbound_tkn, inbound_tkn } = _1.Market.getOutboundInbound(this.ba, this.market.base, this.market.quote);
        return await this.market.mgv.contract.configInfo(outbound_tkn.address, inbound_tkn.address, { blockTag: blockNumber });
    }
    /** Returns the number of offers in the cache. */
    size() {
        return __classPrivateFieldGet(this, _Semibook_offerCache, "f").size;
    }
    /** Returns the id of the best offer in the cache */
    getBestInCache() {
        return __classPrivateFieldGet(this, _Semibook_bestInCache, "f");
    }
    /** Returns an iterator over the offers in the cache. */
    [(_Semibook_offer_gasbase = new WeakMap(), _Semibook_canInitialize = new WeakMap(), _Semibook_blockEventCallback = new WeakMap(), _Semibook_eventFilter = new WeakMap(), _Semibook_eventListener = new WeakMap(), _Semibook_logQueue = new WeakMap(), _Semibook_cacheLock = new WeakMap(), _Semibook_offerCache = new WeakMap(), _Semibook_bestInCache = new WeakMap(), _Semibook_worstInCache = new WeakMap(), _Semibook_lastReadBlockNumber = new WeakMap(), _Semibook_instances = new WeakSet(), Symbol.iterator)]() {
        return new CacheIterator(__classPrivateFieldGet(this, _Semibook_offerCache, "f"), __classPrivateFieldGet(this, _Semibook_bestInCache, "f"));
    }
    /** Convenience method for getting an iterator without having to call `[Symbol.iterator]()`. */
    iter() {
        return this[Symbol.iterator]();
    }
    /** Given a price, find the id of the immediately-better offer in the
     * semibook. If there is no offer with a better price, `undefined` is returned.
     */
    async getPivotId(price) {
        // We select as pivot the immediately-better offer.
        // The actual ordering in the offer list is lexicographic
        // price * gasreq (or price^{-1} * gasreq)
        // We ignore the gasreq comparison because we may not
        // know the gasreq (could be picked by offer contract)
        const priceAsBig = (0, big_js_1.Big)(price);
        const result = await __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_foldLeftUntil).call(this, {
            pivotFound: false,
            pivotId: undefined,
        }, (accumulator) => accumulator.pivotFound, (offer, accumulator) => {
            if (this.isPriceWorse(offer.price, priceAsBig)) {
                accumulator.pivotFound = true;
            }
            else {
                accumulator.pivotId = offer.id;
            }
            return accumulator;
        });
        return result.pivotId;
    }
    /**
     * Volume estimator.
     *
     * if you say `estimateVolume({given:100,to:"buy"})`,
     *
     * it will give you an estimate of how much quote token you would have to
     * spend to get 100 base tokens.
     *
     * if you say `estimateVolume({given:10,to:"sell"})`,
     *
     * it will given you an estimate of how much base tokens you'd have to buy in
     * order to spend 10 quote tokens.
     *
     * if you add a `boundary` field, it either means
     * - the minimum amount you want to receive if you spend all `given` (if to:"sell"), or
     * - the maximum amount you are ready to spend if you buy all `given` (if to:"buy")
     *
     * So for instance, if you say {given:10,to:"sell",boundary:"5"}, estimateVolume will return the volume you will be able to receive if selling up to 10 at a min price of 10/5.
     *
     * The returned `givenResidue` is how much of the given token that cannot be
     * traded due to insufficient volume on the book / price becoming bad.
     */
    async estimateVolume(params) {
        const buying = params.to == "buy";
        // normalize params, if no limit given then:
        // if 'buying N units' set max sell to max(uint256),
        // if 'selling N units' set buy desire to 0
        const boundary = "boundary" in params
            ? params.boundary
            : buying
                ? (0, big_js_1.Big)(2).pow(256).minus(1)
                : 0;
        const initialWants = (0, big_js_1.Big)(buying ? params.given : boundary);
        const initialGives = (0, big_js_1.Big)(buying ? boundary : params.given);
        const { wants, gives, totalGot, totalGave } = await this.simulateMarketOrder(initialWants, initialGives, buying);
        const estimatedVolume = buying ? totalGave : totalGot;
        const givenResidue = buying ? wants : gives;
        return { estimatedVolume, givenResidue };
    }
    /* Reproduces the logic of MgvOfferTaking's internalMarketOrder & execute functions faithfully minus the overflow protections due to bounds on input sizes. */
    async simulateMarketOrder(initialWants, initialGives, fillWants) {
        // reproduce solidity behavior
        const previousBigRm = big_js_1.Big.RM;
        big_js_1.Big.RM = big_js_1.Big.roundDown;
        const initialAccumulator = {
            stop: false,
            wants: initialWants,
            gives: initialGives,
            totalGot: (0, big_js_1.Big)(0),
            totalGave: (0, big_js_1.Big)(0),
        };
        const res = await __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_foldLeftUntil).call(this, initialAccumulator, (acc) => {
            return !(!acc.stop && (fillWants ? acc.wants.gt(0) : acc.gives.gt(0)));
        }, (offer, acc) => {
            const takerWants = acc.wants;
            const takerGives = acc.gives;
            // bad price
            if (takerWants.mul(offer.wants).gt(takerGives.mul(offer.gives))) {
                acc.stop = true;
            }
            else {
                if ((fillWants && takerWants.gt(offer.gives)) ||
                    (!fillWants && takerGives.gt(offer.wants))) {
                    acc.wants = offer.gives;
                    acc.gives = offer.wants;
                }
                else {
                    if (fillWants) {
                        const product = takerWants.mul(offer.wants);
                        /* Reproduce the mangrove round-up of takerGives using Big's rounding mode. */
                        big_js_1.Big.RM = big_js_1.Big.roundUp;
                        acc.gives = product.div(offer.gives);
                        big_js_1.Big.RM = big_js_1.Big.roundDown;
                    }
                    else {
                        if (offer.wants.eq(0)) {
                            acc.wants = offer.gives;
                        }
                        else {
                            acc.wants = takerGives.mul(offer.gives).div(offer.wants);
                        }
                    }
                }
            }
            if (!acc.stop) {
                acc.totalGot = acc.totalGot.add(acc.wants);
                acc.totalGave = acc.totalGave.add(acc.gives);
                acc.wants = initialWants.gt(acc.totalGot)
                    ? initialWants.sub(acc.totalGot)
                    : (0, big_js_1.Big)(0);
                acc.gives = initialGives.sub(acc.totalGave);
            }
            return acc;
        });
        big_js_1.Big.RM = previousBigRm;
        return res;
    }
    /** Returns `true` if `price` is better than `referencePrice`; Otherwise, `false` is returned.
     */
    isPriceBetter(price, referencePrice) {
        return this.tradeManagement.isPriceBetter(price, referencePrice, this.ba);
    }
    /** Returns `true` if `price` is worse than `referencePrice`; Otherwise, `false` is returned.
     */
    isPriceWorse(price, referencePrice) {
        return this.tradeManagement.isPriceWorse(price, referencePrice, this.ba);
    }
    async getMaxGasReq() {
        // TODO: The implementation of the following predicate is work-in-progress
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const countOfferForMaxGasPredicate = (_o) => true;
        const result = await __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_foldLeftUntil).call(this, { maxGasReq: undefined }, () => {
            return false;
        }, (cur, acc) => {
            if (countOfferForMaxGasPredicate(cur)) {
                if (acc.maxGasReq === undefined) {
                    acc.maxGasReq = cur.gasreq;
                }
                else {
                    acc.maxGasReq = Math.max(cur.gasreq, acc.maxGasReq);
                }
            }
            return acc;
        });
        return result.maxGasReq;
    }
    static rawLocalConfigToLocalConfig(local, outboundDecimals) {
        return {
            active: local.active,
            fee: local.fee.toNumber(),
            density: unitCalculations_1.default.fromUnits(local.density, outboundDecimals),
            offer_gasbase: local.offer_gasbase.toNumber(),
            lock: local.lock,
            best: Semibook.rawIdToId(local.best),
            last: Semibook.rawIdToId(local.last),
        };
    }
    static rawIdToId(rawId) {
        const id = rawId.toNumber();
        return id === 0 ? undefined : id;
    }
    static getIsVolumeDesiredForAsks(opts) {
        return (opts.desiredVolume !== undefined &&
            ((opts.desiredVolume.what === "base" &&
                opts.desiredVolume.to === "buy") ||
                (opts.desiredVolume.what === "quote" &&
                    opts.desiredVolume.to === "sell")));
    }
    static getIsVolumeDesiredForBids(opts) {
        return (opts.desiredVolume !== undefined &&
            ((opts.desiredVolume.what === "base" &&
                opts.desiredVolume.to === "sell") ||
                (opts.desiredVolume.what === "quote" &&
                    opts.desiredVolume.to === "buy")));
    }
}
_Semibook_foldLeftUntil = 
// Fold over offers until `stopCondition` is met.
// If cache is insufficient, fetch more offers in batches until `stopCondition` is met.
// All fetched offers are inserted in the cache if there is room.
async function _Semibook_foldLeftUntil(accumulator, // NB: Must work with cloning by `Object.assign`
stopCondition, op) {
    // Store accumulator in case we need to rerun after locking the cache
    const originalAccumulator = accumulator;
    // Fold only on current cache
    accumulator = __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_foldLeftUntilInCache).call(this, Object.assign({}, originalAccumulator), stopCondition, op);
    if (stopCondition(accumulator)) {
        return accumulator;
    }
    // Are we certain to be at the end of the book?
    const isCacheCertainlyComplete = __classPrivateFieldGet(this, _Semibook_offerCache, "f").size > 0 &&
        __classPrivateFieldGet(this, _Semibook_offerCache, "f").get(__classPrivateFieldGet(this, _Semibook_worstInCache, "f")).next === undefined;
    if (isCacheCertainlyComplete) {
        return accumulator;
    }
    // Either the offer list is empty or the cache is insufficient.
    // Lock the cache as we are going to fetch more offers and put them in the cache
    return await __classPrivateFieldGet(this, _Semibook_cacheLock, "f").runExclusive(async () => {
        // When the lock has been obtained, the cache may have changed,
        // so we need to restart from the beginning
        // Fold only on current cache
        accumulator = __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_foldLeftUntilInCache).call(this, Object.assign({}, originalAccumulator), stopCondition, op);
        if (stopCondition(accumulator)) {
            return accumulator;
        }
        // Are we certain to be at the end of the book?
        const isCacheCertainlyComplete = __classPrivateFieldGet(this, _Semibook_offerCache, "f").size > 0 &&
            __classPrivateFieldGet(this, _Semibook_offerCache, "f").get(__classPrivateFieldGet(this, _Semibook_worstInCache, "f")).next === undefined;
        if (isCacheCertainlyComplete) {
            return accumulator;
        }
        // Either the offer list is still empty or the cache is still insufficient.
        // Try to fetch more offers to complete the fold
        const nextId = __classPrivateFieldGet(this, _Semibook_offerCache, "f").get(__classPrivateFieldGet(this, _Semibook_worstInCache, "f"))?.next;
        await __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_fetchOfferListPrefixUntil).call(this, __classPrivateFieldGet(this, _Semibook_lastReadBlockNumber, "f"), nextId, this.options.chunkSize, (chunk) => {
            for (const offer of chunk) {
                // We try to insert all the fetched offers in case the cache is not at max size
                __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_insertOffer).call(this, offer);
                // Only apply op f stop condition is _not_ met
                if (!stopCondition(accumulator)) {
                    accumulator = op(offer, accumulator);
                }
            }
            return stopCondition(accumulator);
        });
        return accumulator;
    });
}, _Semibook_foldLeftUntilInCache = function _Semibook_foldLeftUntilInCache(accumulator, stopCondition, op) {
    for (const offer of this) {
        accumulator = op(offer, accumulator);
        if (stopCondition(accumulator))
            break;
    }
    return accumulator;
}, _Semibook_initialize = async function _Semibook_initialize() {
    if (!__classPrivateFieldGet(this, _Semibook_canInitialize, "f"))
        return;
    __classPrivateFieldSet(this, _Semibook_canInitialize, false, "f");
    // To avoid missing any events, we register the event listener before
    // reading the offer list. However, the events must not be processed
    // before the semibook has been initialized. This is ensured by
    // locking the cache and having the event listener await and take that lock.
    await __classPrivateFieldGet(this, _Semibook_cacheLock, "f").runExclusive(async () => {
        // handle provider events
        this.market.mgv.provider.on(__classPrivateFieldGet(this, _Semibook_eventFilter, "f"), (log) => {
            __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_handleBookEventFromProvider).call(this, log);
        });
        // To ensure consistency in this cache, everything is initially fetched from a specific block
        __classPrivateFieldSet(this, _Semibook_lastReadBlockNumber, await this.market.mgv.provider.getBlockNumber(), "f");
        const localConfig = await this.getConfig(__classPrivateFieldGet(this, _Semibook_lastReadBlockNumber, "f"));
        __classPrivateFieldSet(this, _Semibook_offer_gasbase, localConfig.offer_gasbase, "f");
        const offers = await __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_fetchOfferListPrefix).call(this, __classPrivateFieldGet(this, _Semibook_lastReadBlockNumber, "f"));
        if (offers.length > 0) {
            __classPrivateFieldSet(this, _Semibook_bestInCache, offers[0].id, "f");
            __classPrivateFieldSet(this, _Semibook_worstInCache, offers[offers.length - 1].id, "f");
            for (const offer of offers) {
                __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_insertOffer).call(this, offer);
            }
        }
    });
}, _Semibook_handleBookEventFromProvider = function _Semibook_handleBookEventFromProvider(ethersLog) {
    __classPrivateFieldGet(this, _Semibook_logQueue, "f").push(ethersLog);
    __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_handleBookEvents).call(this);
}, _Semibook_handleBookEvents = async function _Semibook_handleBookEvents() {
    await __classPrivateFieldGet(this, _Semibook_cacheLock, "f").runExclusive(async () => {
        __classPrivateFieldGet(this, _Semibook_logQueue, "f").forEach((l) => __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_handleBookEvent).call(this, l));
        __classPrivateFieldSet(this, _Semibook_logQueue, [], "f");
    });
}, _Semibook_handleBookEvent = function _Semibook_handleBookEvent(ethersLog) {
    const event = this.market.mgv.contract.interface.parseLog(ethersLog);
    let offer;
    let removedOffer;
    let next;
    const { outbound_tkn, inbound_tkn } = this.market.getOutboundInbound(this.ba);
    switch (event.name) {
        case "OfferWrite": {
            // We ignore the return value here because the offer may have been outside the local
            // cache, but may now enter the local cache due to its new price.
            const id = Semibook.rawIdToId(event.args.id);
            const prev = Semibook.rawIdToId(event.args.prev);
            let expectOfferInsertionInCache = true;
            __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_removeOffer).call(this, id);
            /* After removing the offer (a noop if the offer was not in local cache), we reinsert it.
             * The offer comes with id of its prev. If prev does not exist in cache, we skip
             * the event. Note that we still want to remove the offer from the cache.
             * If the prev exists, we take the prev's next as the offer's next.
             * Whether that next exists in the cache or not is irrelevant.
             */
            if (prev === undefined) {
                // The removed offer will be the best, so the next offer is the current best
                next = __classPrivateFieldGet(this, _Semibook_bestInCache, "f");
            }
            else if (__classPrivateFieldGet(this, _Semibook_offerCache, "f").has(prev)) {
                next = __classPrivateFieldGet(this, _Semibook_offerCache, "f").get(prev).next;
            }
            else {
                // offer.prev was not found, we are outside local OB copy.
                expectOfferInsertionInCache = false;
            }
            if (expectOfferInsertionInCache) {
                offer = {
                    offer_gasbase: __classPrivateFieldGet(this, _Semibook_offer_gasbase, "f"),
                    next: next,
                    ...this.tradeManagement.tradeEventManagement.rawOfferToOffer(this.market, this.ba, event.args),
                };
                if (!__classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_insertOffer).call(this, offer)) {
                    // Offer was not inserted
                    expectOfferInsertionInCache = false;
                }
            }
            __classPrivateFieldGet(this, _Semibook_eventListener, "f").call(this, {
                cbArg: {
                    type: event.name,
                    offer: expectOfferInsertionInCache ? offer : undefined,
                    offerId: id,
                    ba: this.ba,
                },
                event,
                ethersLog: ethersLog,
            });
            break;
        }
        case "OfferFail": {
            const id = Semibook.rawIdToId(event.args.id);
            removedOffer = __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_removeOffer).call(this, id);
            __classPrivateFieldGet(this, _Semibook_eventListener, "f").call(this, {
                cbArg: {
                    type: event.name,
                    ba: this.ba,
                    taker: event.args.taker,
                    offer: removedOffer,
                    offerId: id,
                    takerWants: outbound_tkn.fromUnits(event.args.takerWants),
                    takerGives: inbound_tkn.fromUnits(event.args.takerGives),
                    mgvData: ethers_1.ethers.utils.parseBytes32String(event.args.mgvData),
                },
                event,
                ethersLog: ethersLog,
            });
            break;
        }
        case "OfferSuccess": {
            const id = Semibook.rawIdToId(event.args.id);
            removedOffer = __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_removeOffer).call(this, id);
            __classPrivateFieldGet(this, _Semibook_eventListener, "f").call(this, {
                cbArg: {
                    type: event.name,
                    ba: this.ba,
                    taker: event.args.taker,
                    offer: removedOffer,
                    offerId: id,
                    takerWants: outbound_tkn.fromUnits(event.args.takerWants),
                    takerGives: inbound_tkn.fromUnits(event.args.takerGives),
                },
                event,
                ethersLog: ethersLog,
            });
            break;
        }
        case "OfferRetract": {
            const id = Semibook.rawIdToId(event.args.id);
            removedOffer = __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_removeOffer).call(this, id);
            __classPrivateFieldGet(this, _Semibook_eventListener, "f").call(this, {
                cbArg: {
                    type: event.name,
                    ba: this.ba,
                    offerId: id,
                    offer: removedOffer,
                },
                event,
                ethersLog: ethersLog,
            });
            break;
        }
        case "SetGasbase":
            __classPrivateFieldSet(this, _Semibook_offer_gasbase, event.args.offer_gasbase.toNumber(), "f");
            __classPrivateFieldGet(this, _Semibook_eventListener, "f").call(this, {
                cbArg: {
                    type: event.name,
                    ba: this.ba,
                },
                event,
                ethersLog: ethersLog,
            });
            break;
        default:
            throw Error(`Unknown event ${event}`);
    }
}, _Semibook_insertOffer = function _Semibook_insertOffer(offer) {
    // Only insert offers that are extensions of the cache
    if (offer.prev !== undefined && !__classPrivateFieldGet(this, _Semibook_offerCache, "f").has(offer.prev)) {
        return false;
    }
    __classPrivateFieldGet(this, _Semibook_offerCache, "f").set(offer.id, offer);
    if (offer.prev === undefined) {
        __classPrivateFieldSet(this, _Semibook_bestInCache, offer.id, "f");
    }
    else {
        __classPrivateFieldGet(this, _Semibook_offerCache, "f").get(offer.prev).next = offer.id;
    }
    if (offer.prev === __classPrivateFieldGet(this, _Semibook_worstInCache, "f")) {
        __classPrivateFieldSet(this, _Semibook_worstInCache, offer.id, "f");
    }
    const nextOffer = __classPrivateFieldGet(this, _Semibook_offerCache, "f").get(offer.next);
    if (nextOffer !== undefined) {
        nextOffer.prev = offer.id;
    }
    // If maxOffers option has been specified, evict worst offer if over max size
    if (this.options.maxOffers !== undefined &&
        __classPrivateFieldGet(this, _Semibook_offerCache, "f").size > this.options.maxOffers) {
        const removedOffer = __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_removeOffer).call(this, __classPrivateFieldGet(this, _Semibook_worstInCache, "f"));
        if (offer.id === removedOffer?.id) {
            return false;
        }
    }
    return true;
}, _Semibook_removeOffer = function _Semibook_removeOffer(id) {
    const offer = __classPrivateFieldGet(this, _Semibook_offerCache, "f").get(id);
    if (offer === undefined)
        return undefined;
    if (offer.prev === undefined) {
        __classPrivateFieldSet(this, _Semibook_bestInCache, offer.next, "f");
    }
    else {
        __classPrivateFieldGet(this, _Semibook_offerCache, "f").get(offer.prev).next = offer.next;
    }
    const nextOffer = __classPrivateFieldGet(this, _Semibook_offerCache, "f").get(offer.next);
    if (nextOffer === undefined) {
        __classPrivateFieldSet(this, _Semibook_worstInCache, offer.prev, "f");
    }
    else {
        nextOffer.prev = offer.prev;
    }
    __classPrivateFieldGet(this, _Semibook_offerCache, "f").delete(id);
    return offer;
}, _Semibook_fetchOfferListPrefix = 
/** Fetches offers from the network.
 *
 * If options are given, those are used instead of the options
 * given when constructing the Semibook.
 */
async function _Semibook_fetchOfferListPrefix(blockNumber, fromId, options) {
    options = __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_setDefaultsAndValidateOptions).call(this, options ?? this.options);
    if (options.desiredPrice !== undefined) {
        return await __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_fetchOfferListPrefixUntil).call(this, blockNumber, fromId, options.chunkSize, (chunk) => chunk.length === 0
            ? true
            : this.isPriceBetter(options.desiredPrice, chunk[chunk.length - 1].price));
    }
    else if (options.desiredVolume !== undefined) {
        const filler = options.desiredVolume.to === "buy" ? "gives" : "wants";
        let volume = (0, big_js_1.Big)(0);
        return await __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_fetchOfferListPrefixUntil).call(this, blockNumber, fromId, options.chunkSize, (chunk) => {
            chunk.forEach((offer) => {
                volume = volume.plus(offer[filler]);
            });
            return volume.gte(options.desiredVolume.given);
        });
    }
    else {
        return await __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_fetchOfferListPrefixUntil).call(this, blockNumber, fromId, options.chunkSize, (chunk, allFetched) => allFetched.length >= options.maxOffers);
    }
}, _Semibook_fetchOfferListPrefixUntil = 
/** Fetches offers from the network until a condition is met. */
async function _Semibook_fetchOfferListPrefixUntil(blockNumber, fromId, chunkSize, processChunk // Should return `true` when fetching should stop
) {
    const { outbound_tkn, inbound_tkn } = this.market.getOutboundInbound(this.ba);
    let chunk;
    const result = [];
    do {
        const [_nextId, offerIds, offers, details] = await this.market.mgv.readerContract.offerList(outbound_tkn.address, inbound_tkn.address, __classPrivateFieldGet(this, _Semibook_instances, "m", _Semibook_idToRawId).call(this, fromId), chunkSize, { blockTag: blockNumber });
        chunk = offerIds.map((offerId, index) => {
            const offer = offers[index];
            const detail = details[index];
            return {
                next: Semibook.rawIdToId(offer.next),
                offer_gasbase: detail.offer_gasbase.toNumber(),
                ...this.tradeManagement.tradeEventManagement.rawOfferToOffer(this.market, this.ba, {
                    id: offerId,
                    ...offer,
                    ...detail,
                }),
            };
        });
        result.push(...chunk);
        fromId = Semibook.rawIdToId(_nextId);
    } while (!processChunk(chunk, result) && fromId !== undefined);
    return result;
}, _Semibook_rawLocalConfigToLocalConfig = function _Semibook_rawLocalConfigToLocalConfig(local) {
    const { outbound_tkn } = this.market.getOutboundInbound(this.ba);
    return Semibook.rawLocalConfigToLocalConfig(local, outbound_tkn.decimals);
}, _Semibook_idToRawId = function _Semibook_idToRawId(id) {
    return id === undefined ? ethers_1.BigNumber.from(0) : ethers_1.BigNumber.from(id);
}, _Semibook_createEventFilter = function _Semibook_createEventFilter() {
    /* Disjunction of possible event names */
    const topics0 = [
        "OfferSuccess",
        "OfferFail",
        "OfferWrite",
        "OfferRetract",
        "SetGasbase",
    ].map((e) => this.market.mgv.contract.interface.getEventTopic(this.market.mgv.contract.interface.getEvent(e)));
    const base_padded = ethers_1.ethers.utils.hexZeroPad(this.market.base.address, 32);
    const quote_padded = ethers_1.ethers.utils.hexZeroPad(this.market.quote.address, 32);
    const topics = this.ba === "asks"
        ? [topics0, base_padded, quote_padded]
        : [topics0, quote_padded, base_padded];
    return {
        address: this.market.mgv.address,
        topics: topics,
    };
}, _Semibook_setDefaultsAndValidateOptions = function _Semibook_setDefaultsAndValidateOptions(options) {
    const result = Object.assign({}, options);
    const countCacheContentOptions = (options.maxOffers !== undefined ? 1 : 0) +
        (options.desiredPrice !== undefined ? 1 : 0) +
        (options.desiredVolume !== undefined ? 1 : 0);
    if (countCacheContentOptions > 1) {
        throw Error("Only one of maxOffers, desiredPrice, and desiredVolume can be specified");
    }
    if (options.maxOffers !== undefined && options.maxOffers < 0) {
        throw Error("Semibook options.maxOffers must be >= 0");
    }
    if (result.chunkSize === undefined) {
        result.chunkSize =
            result.maxOffers !== undefined && result.maxOffers > 0
                ? result.maxOffers
                : Semibook.DEFAULT_MAX_OFFERS;
    }
    if (options.chunkSize <= 0) {
        throw Error("Semibook options.chunkSize must be > 0");
    }
    return result;
};
Semibook.DEFAULT_MAX_OFFERS = 50;
class CacheIterator {
    constructor(offerCache, bestInCache, predicate = () => true) {
        _CacheIterator_offerCache.set(this, void 0);
        _CacheIterator_latest.set(this, void 0);
        _CacheIterator_predicate.set(this, void 0);
        __classPrivateFieldSet(this, _CacheIterator_offerCache, offerCache, "f");
        __classPrivateFieldSet(this, _CacheIterator_latest, bestInCache, "f");
        __classPrivateFieldSet(this, _CacheIterator_predicate, predicate, "f");
    }
    [(_CacheIterator_offerCache = new WeakMap(), _CacheIterator_latest = new WeakMap(), _CacheIterator_predicate = new WeakMap(), Symbol.iterator)]() {
        return this;
    }
    next() {
        let value;
        do {
            value =
                __classPrivateFieldGet(this, _CacheIterator_latest, "f") === undefined
                    ? undefined
                    : __classPrivateFieldGet(this, _CacheIterator_offerCache, "f").get(__classPrivateFieldGet(this, _CacheIterator_latest, "f"));
            __classPrivateFieldSet(this, _CacheIterator_latest, value?.next, "f");
        } while (value !== undefined &&
            __classPrivateFieldGet(this, _CacheIterator_predicate, "f") !== undefined &&
            !__classPrivateFieldGet(this, _CacheIterator_predicate, "f").call(this, value));
        return {
            done: value === undefined,
            value: value,
        };
    }
    filter(predicate) {
        return new CacheIterator(__classPrivateFieldGet(this, _CacheIterator_offerCache, "f"), __classPrivateFieldGet(this, _CacheIterator_latest, "f"), (o) => __classPrivateFieldGet(this, _CacheIterator_predicate, "f").call(this, o) && predicate(o));
    }
    find(predicate) {
        for (const element of this) {
            if (predicate(element)) {
                return element;
            }
        }
        return undefined;
    }
    toArray() {
        return [...this];
    }
}
exports.default = Semibook;
//# sourceMappingURL=semibook.js.map
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ThresholdBlockSubscriptions_instances, _ThresholdBlockSubscriptions_byBlock, _ThresholdBlockSubscriptions_lastSeen, _ThresholdBlockSubscriptions_seenThreshold, _ThresholdBlockSubscriptions_get, _ThresholdBlockSubscriptions_set;
Object.defineProperty(exports, "__esModule", { value: true });
/* Instances of this class react to incoming blocks once the blocks have been seen enough times.

Usage:
* You register a `callback` for a given block `n` using `subscribe(n,callback)`. Once the block _or any later block_ has been seen `>= seenThreshold` times, `callback` is executed.
* You signal that a block `m` has been seen using `increaseCount(m)`. This will increase the `seenCount` of block `m`, and possibly execute all callbacks associated to blocks `m'<=m` if the updated `seenCount` is strictly greater than `seenThreshold`.

The constructor takes `lastSeen:number` argument (the starting block number), and a `seenThreshold:number` argument (the number of times a block must be seen before its associated callbacks are executed).

Motivation: a Mangrove market has two semibooks, and may receive updates from each at different times, but it should only trigger the "market has been updated" callback once both semibooks have gotten their updates. In addition, a callback for block n may be registered after block `m > n` has been observed, so this class searches through previous block's registered callbacks when it crosses a `seenThreshold`.

Callbacks are discarded before execution.

*/
class ThresholdBlockSubscriptions {
    constructor(lastSeen, seenThreshold) {
        _ThresholdBlockSubscriptions_instances.add(this);
        _ThresholdBlockSubscriptions_byBlock.set(this, void 0);
        _ThresholdBlockSubscriptions_lastSeen.set(this, void 0);
        _ThresholdBlockSubscriptions_seenThreshold.set(this, void 0);
        __classPrivateFieldSet(this, _ThresholdBlockSubscriptions_seenThreshold, seenThreshold, "f");
        __classPrivateFieldSet(this, _ThresholdBlockSubscriptions_lastSeen, lastSeen, "f");
        __classPrivateFieldSet(this, _ThresholdBlockSubscriptions_byBlock, new Map(), "f");
    }
    // assumes increaseCount(n) is called monotonically in n
    increaseCount(n) {
        // seeing an already-seen-enough block (should not occur)
        if (n <= __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_lastSeen, "f")) {
            return;
        }
        const { seenCount, cbs } = __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_instances, "m", _ThresholdBlockSubscriptions_get).call(this, n);
        __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_instances, "m", _ThresholdBlockSubscriptions_set).call(this, n, seenCount + 1, cbs);
        // havent seen the block enough times
        if (seenCount + 1 < __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_seenThreshold, "f")) {
            return;
        }
        const prevLastSeen = __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_lastSeen, "f");
        __classPrivateFieldSet(this, _ThresholdBlockSubscriptions_lastSeen, n, "f");
        // clear all past callbacks
        for (let i = prevLastSeen + 1; i <= n; i++) {
            const { cbs: _cbs } = __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_instances, "m", _ThresholdBlockSubscriptions_get).call(this, i);
            __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_byBlock, "f").delete(i);
            for (const cb of _cbs) {
                cb(i);
            }
        }
    }
    subscribe(n, cb) {
        if (__classPrivateFieldGet(this, _ThresholdBlockSubscriptions_lastSeen, "f") >= n) {
            return Promise.resolve(cb(n));
        }
        else {
            const { seenCount, cbs } = __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_instances, "m", _ThresholdBlockSubscriptions_get).call(this, n);
            return new Promise((ok, ko) => {
                const _cb = (n) => Promise.resolve(cb(n)).then(ok, ko);
                __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_instances, "m", _ThresholdBlockSubscriptions_set).call(this, n, seenCount, cbs.add(_cb));
            });
        }
    }
}
_ThresholdBlockSubscriptions_byBlock = new WeakMap(), _ThresholdBlockSubscriptions_lastSeen = new WeakMap(), _ThresholdBlockSubscriptions_seenThreshold = new WeakMap(), _ThresholdBlockSubscriptions_instances = new WeakSet(), _ThresholdBlockSubscriptions_get = function _ThresholdBlockSubscriptions_get(n) {
    return __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_byBlock, "f").get(n) || { seenCount: 0, cbs: new Set() };
}, _ThresholdBlockSubscriptions_set = function _ThresholdBlockSubscriptions_set(n, seenCount, cbs) {
    __classPrivateFieldGet(this, _ThresholdBlockSubscriptions_byBlock, "f").set(n, { seenCount, cbs });
};
exports.default = ThresholdBlockSubscriptions;
//# sourceMappingURL=ThresholdBlockSubscriptions.js.map
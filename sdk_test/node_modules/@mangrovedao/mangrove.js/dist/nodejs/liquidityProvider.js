"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _LiquidityProvider_instances, _LiquidityProvider_gasreq, _LiquidityProvider_constructPromise, _LiquidityProvider_approveToken;
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("./util/logger");
const mangrove_1 = __importDefault(require("./mangrove"));
/* Note on big.js:
ethers.js's BigNumber (actually BN.js) only handles integers
big.js handles arbitrary precision decimals, which is what we want
for more on big.js vs decimals.js vs. bignumber.js (which is *not* ethers's BigNumber):
  github.com/MikeMcl/big.js/issues/45#issuecomment-104211175
*/
const big_js_1 = __importDefault(require("big.js"));
const prettyPrint_1 = __importDefault(require("./util/prettyPrint"));
/**
 * The LiquidityProvider class connects an offerLogic (or an EOA) to a market.
 * It posts onchain offers.
 * */
class LiquidityProvider {
    constructor(p) {
        _LiquidityProvider_instances.add(this);
        this.prettyP = new prettyPrint_1.default();
        if (p.eoa || p.logic) {
            this.mgv = p.mgv;
            this.logic = p.logic;
            this.market = p.market;
            this.eoa = p.eoa;
        }
        else {
            throw Error("Missing EOA or onchain logic to build a Liquidity Provider object");
        }
    }
    computeOfferProvision(ba, opts = {}) {
        return this.getMissingProvision(ba, opts);
    }
    computeBidProvision(opts = {}) {
        return this.getMissingProvision("bids", opts);
    }
    computeAskProvision(opts = {}) {
        return this.getMissingProvision("asks", opts);
    }
    /** Given a price, find the id of the immediately-better offer in the
     * semibook. If there is no offer with a better price, `undefined` is returned.
     */
    async getBidPivotId(price) {
        const book = this.market.getBook();
        return book.bids.getPivotId(price);
    }
    async getAskPivotId(price) {
        const book = this.market.getBook();
        return book.asks.getPivotId(price);
    }
    /** List all of the maker's asks in the cache */
    asks() {
        const address = this.logic ? this.logic.address : this.eoa;
        return this.market
            .getBook()
            .asks.iter()
            .filter((ofr) => ofr.maker === address)
            .toArray();
    }
    /** List all of the maker's bids in the cache */
    bids() {
        const address = this.logic ? this.logic.address : this.eoa;
        return this.market
            .getBook()
            .bids.iter()
            .filter((ofr) => ofr.maker === address)
            .toArray();
    }
    /** Pretty prints the current state of the asks for the maker */
    consoleAsks(filter) {
        this.prettyP.consoleOffers(this.asks(), filter);
    }
    /** Pretty prints the current state of the bids for the maker */
    consoleBids(filter) {
        this.prettyP.consoleOffers(this.bids(), filter);
    }
    /**
     *  Given offer params (bids/asks + price info as wants&gives or price&volume),
     *  return {price,wants,gives}
     */
    static normalizeOfferParams(p) {
        let wants, gives, price;
        // deduce price from wants&gives, or deduce wants&gives from volume&price
        if ("gives" in p) {
            [wants, gives] = [p.wants, p.gives];
            let [base_amt, quote_amt] = [gives, wants];
            if (p.ba === "bids") {
                [base_amt, quote_amt] = [quote_amt, base_amt];
            }
            price = (0, big_js_1.default)(quote_amt).div(base_amt);
        }
        else {
            price = p.price;
            [wants, gives] = [(0, big_js_1.default)(p.volume).mul(price), (0, big_js_1.default)(p.volume)];
            if (p.ba === "bids") {
                [wants, gives] = [gives, wants];
            }
        }
        const fund = p.fund;
        return { wants, gives, price, fund };
    }
    static optValueToPayableOverride(overrides, fund) {
        if (fund) {
            return { value: mangrove_1.default.toUnits(fund, 18), ...overrides };
        }
        else {
            return overrides;
        }
    }
    /** Post a new ask */
    newAsk(p, overrides = {}) {
        return this.newOffer({ ba: "asks", ...p }, overrides);
    }
    /** Post a new bid */
    newBid(p, overrides = {}) {
        return this.newOffer({ ba: "bids", ...p }, overrides);
    }
    /* Create a new offer, let mangrove decide the gasprice. Return a promise fulfilled when mangrove.js has received the tx and updated itself. The tx returns the new offer id.
   
      If the tx created more than one offer, the id of the first one to be written is returned.
    
      Note: we do not return a TransactionResponse because it could be possible to :
       * wait for the response to be mined
       * try to read market.book
       * still get the old book (before new offer is inserted)
      This is due to ethers.js subscription calling the txresponse first and
      updating subscriptions only later.
      To avoid inconsistency we do a market.once(...) which fulfills the promise once the offer has been created.
    */
    /* Returns an easy to use promise of a view of the new offer. You can also catch any error thrown if the transaction was rejected/replaced. */
    async newOffer(p, overrides = {}) {
        const { wants, gives, price, fund } = LiquidityProvider.normalizeOfferParams(p);
        const { outbound_tkn, inbound_tkn } = this.market.getOutboundInbound(p.ba);
        const pivot = await this.market.getPivotId(p.ba, price);
        let txPromise = null;
        // send offer
        if (this.logic) {
            txPromise = this.logic.contract.newOffer(outbound_tkn.address, inbound_tkn.address, inbound_tkn.toUnits(wants), outbound_tkn.toUnits(gives), pivot ? pivot : 0, LiquidityProvider.optValueToPayableOverride(overrides, fund));
        }
        else {
            txPromise = this.mgv.contract.newOffer(outbound_tkn.address, inbound_tkn.address, inbound_tkn.toUnits(wants), outbound_tkn.toUnits(gives), 0, //gasreq
            0, //gasprice
            pivot ? pivot : 0, LiquidityProvider.optValueToPayableOverride(overrides, fund));
        }
        logger_1.logger.debug(`Post new offer`, {
            contextInfo: "mangrove.maker",
            data: { params: p, overrides: overrides },
        });
        return __classPrivateFieldGet(this, _LiquidityProvider_instances, "m", _LiquidityProvider_constructPromise).call(this, this.market, (_cbArg, _bookEvent, _ethersLog) => ({
            id: _cbArg.offerId,
            pivot: pivot,
            event: _ethersLog,
        }), txPromise, (cbArg) => cbArg.type === "OfferWrite");
    }
    /** Update an existing ask */
    /** e.g `updateAsk(42,{price:0.2, volume:1000, gasreq:100000, fund:0.01})`*/
    /** to change volume and price of the offer, and update its gas requirement and fund 0.01 ether to maker balance*/
    updateAsk(id, p, overrides = {}) {
        return this.updateOffer(id, { ba: "asks", ...p }, overrides);
    }
    /** Update an existing offer */
    updateBid(id, p, overrides = {}) {
        return this.updateOffer(id, { ba: "bids", ...p }, overrides);
    }
    /* Update an existing offer. Non-specified parameters will be copied from current
       data in the offer. Reuse current offer's gasprice if gasprice is undefined
       Input should be {ba:"bids"|"asks"} and price info as wants&gives or as price&volume
       */
    async updateOffer(id, p, overrides = {}) {
        const offer = p.ba === "asks"
            ? await this.market.askInfo(id)
            : await this.market.bidInfo(id);
        if (typeof offer === "undefined") {
            throw Error(`No offer in market with id ${id}.`);
        }
        const thisMaker = this.eoa ? this.eoa : this.logic.address;
        const offerMakerAddress = (await offer).maker;
        if (offerMakerAddress != thisMaker) {
            throw Error(`The offer is owned by a different address ${offerMakerAddress}, not the expected address ${thisMaker}.`);
        }
        const { wants, gives, price, fund } = LiquidityProvider.normalizeOfferParams(p);
        const { outbound_tkn, inbound_tkn } = this.market.getOutboundInbound(p.ba);
        let txPromise = null;
        // update offer
        if (this.logic) {
            txPromise = this.logic.contract.updateOffer(outbound_tkn.address, inbound_tkn.address, inbound_tkn.toUnits(wants), outbound_tkn.toUnits(gives), (await this.market.getPivotId(p.ba, price)) ?? 0, id, LiquidityProvider.optValueToPayableOverride(overrides, fund));
        }
        else {
            txPromise = this.mgv.contract.updateOffer(outbound_tkn.address, inbound_tkn.address, inbound_tkn.toUnits(wants), outbound_tkn.toUnits(gives), 0, 0, (await this.market.getPivotId(p.ba, price)) ?? 0, id, LiquidityProvider.optValueToPayableOverride(overrides, fund));
        }
        logger_1.logger.debug(`Update offer`, {
            contextInfo: "mangrove.maker",
            data: { id: id, params: p, overrides: overrides },
        });
        return __classPrivateFieldGet(this, _LiquidityProvider_instances, "m", _LiquidityProvider_constructPromise).call(this, this.market, (_cbArg, _bookEvent, _ethersLog) => ({
            event: _ethersLog,
        }), txPromise, (cbArg) => cbArg.type === "OfferWrite");
    }
    /** Cancel an ask. If deprovision is true, will return the offer's provision to the maker balance at Mangrove. */
    retractAsk(id, deprovision = false, overrides = {}) {
        return this.retractOffer("asks", id, deprovision, overrides);
    }
    /** Cancel a bid. If deprovision is true, will return the offer's provision to the maker balance at Mangrove. */
    retractBid(id, deprovision = false, overrides = {}) {
        return this.retractOffer("bids", id, deprovision, overrides);
    }
    /* Cancel an offer. Return a promise fulfilled when mangrove.js has received the tx and updated itself. If deprovision is true, will return the offer's provision to the maker balance at Mangrove. */
    async retractOffer(ba, id, deprovision = false, overrides = {}) {
        const { outbound_tkn, inbound_tkn } = this.market.getOutboundInbound(ba);
        const retracter = this.logic ? this.logic.contract : this.mgv.contract;
        let txPromise = null;
        // retract offer
        txPromise = retracter.retractOffer(outbound_tkn.address, inbound_tkn.address, id, deprovision, overrides);
        logger_1.logger.debug(`Cancel offer`, {
            contextInfo: "mangrove.maker",
            data: { id: id, ba: ba, deprovision: deprovision, overrides: overrides },
        });
        return __classPrivateFieldGet(this, _LiquidityProvider_instances, "m", _LiquidityProvider_constructPromise).call(this, this.market, ( /*_cbArg, _bookEvent, _ethersLog*/) => {
            /* intentionally left blank */
        }, txPromise, (cbArg) => cbArg.type === "OfferRetract");
    }
    approveAsks(arg = {}) {
        return __classPrivateFieldGet(this, _LiquidityProvider_instances, "m", _LiquidityProvider_approveToken).call(this, this.market.base.name, arg);
    }
    approveBids(arg = {}) {
        return __classPrivateFieldGet(this, _LiquidityProvider_instances, "m", _LiquidityProvider_approveToken).call(this, this.market.quote.name, arg);
    }
    async getMissingProvision(ba, opts = {}) {
        const gasreq = opts.gasreq ? opts.gasreq : await __classPrivateFieldGet(this, _LiquidityProvider_instances, "m", _LiquidityProvider_gasreq).call(this);
        const gasprice = opts.gasprice ? opts.gasprice : 0;
        // this computes the total provision required for a new offer on the market
        const provision = await this.market.getOfferProvision(ba, gasreq, gasprice);
        let lockedProvision = (0, big_js_1.default)(0);
        // checking now the funds that are either locked in the offer or on the maker balance on Mangrove
        if (opts.id) {
            const { outbound_tkn, inbound_tkn } = this.market.getOutboundInbound(ba);
            lockedProvision = this.mgv.fromUnits(this.logic
                ? await this.logic.contract.provisionOf(outbound_tkn.address, inbound_tkn.address, opts.id)
                : 0, 18);
        }
        logger_1.logger.debug(`Get missing provision`, {
            contextInfo: "mangrove.maker",
            data: { ba: ba, opts: opts },
        });
        if (provision.gt(lockedProvision)) {
            return provision.sub(lockedProvision);
        }
        else {
            return (0, big_js_1.default)(0);
        }
    }
}
_LiquidityProvider_instances = new WeakSet(), _LiquidityProvider_gasreq = async function _LiquidityProvider_gasreq() {
    if (this.eoa) {
        return 0;
    }
    else {
        return await this.logic.offerGasreq();
    }
}, _LiquidityProvider_constructPromise = function _LiquidityProvider_constructPromise(market, cb, txPromise, filter) {
    let promiseResolve;
    let promiseReject;
    const promise = new Promise((resolve, reject) => {
        promiseResolve = resolve;
        promiseReject = reject;
    });
    // catch rejections of the txPromise and reject returned promise
    txPromise.catch((e) => promiseReject(e));
    const callback = async (cbArg, bookEvent, ethersLog) => {
        const txHash = (await txPromise).hash;
        const logTxHash = ethersLog.transactionHash;
        if (txHash === logTxHash && filter(cbArg)) {
            promiseResolve(cb(cbArg, bookEvent, ethersLog));
        }
    };
    market.subscribe(callback); // TODO: subscribe/once ?
    return promise.finally(() => market.unsubscribe(callback));
}, _LiquidityProvider_approveToken = function _LiquidityProvider_approveToken(tokenName, arg = {}) {
    if (this.logic) {
        return this.logic.approveToken(tokenName, arg);
    }
    else {
        // LP is an EOA
        return this.mgv.approveMangrove(tokenName, arg);
    }
};
exports.default = LiquidityProvider;
//# sourceMappingURL=liquidityProvider.js.map
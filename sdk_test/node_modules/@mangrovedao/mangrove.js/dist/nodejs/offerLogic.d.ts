import * as ethers from "ethers";
import Market from "./market";
import { Bigish } from "./types";
import { typechain } from "./types";
import { LiquidityProvider, Mangrove } from ".";
import { TransactionResponse } from "@ethersproject/abstract-provider";
import { ApproveArgs } from "./mgvtoken";
import Big from "big.js";
declare type SignerOrProvider = ethers.ethers.Signer | ethers.ethers.providers.Provider;
/**
 * The OfferLogic class connects to a Maker contract
 */
declare class OfferLogic {
    mgv: Mangrove;
    contract: typechain.ILiquidityProvider;
    address: string;
    constructor(mgv: Mangrove, logic: string, signer?: SignerOrProvider);
    static deploy(mgv: Mangrove): Promise<string>;
    /**
     * @note Returns this logic's router. If logic has no router this call will return `undefined`
     * @returns the router ethers.js contract responding to the `AbstractRouter` abi.
     */
    router(): Promise<typechain.AbstractRouter | undefined>;
    /**
     * @note Approves the logic to spend `token`s on signer's behalf.
     * This has to be done for each token the signer's wishes to ask or bid for.
     * @param arg optional `arg.amount` can be used if one wishes to approve a finite amount
     */
    approveToken(tokenName: string, arg?: ApproveArgs): Promise<ethers.ContractTransaction>;
    /**@note returns logic's allowance to trade `tokenName` on signer's behalf */
    allowance(tokenName: string): Promise<Big>;
    connect(sOp: SignerOrProvider): OfferLogic;
    offerGasreq(): Promise<number>;
    setAdmin(newAdmin: string, overrides?: ethers.Overrides): Promise<TransactionResponse>;
    admin(): Promise<string>;
    /**
     * @note (contract admin action) activates logic
     * @param tokenNames the names of the tokens one wishes the logic to trade
     * */
    activate(tokenNames: string[], overrides?: ethers.Overrides): Promise<TransactionResponse>;
    retractOffer(outbound_tkn: string, inbound_tkn: string, id: number, deprovision: boolean, overrides: ethers.Overrides): Promise<TransactionResponse>;
    /** Withdraw from the OfferLogic's ether balance on Mangrove to the sender's account */
    /** tx will revert is signer is not the admin of the OfferLogic onchain contract */
    withdrawFromMangrove(amount: Bigish, overrides?: ethers.Overrides): Promise<TransactionResponse>;
    /** Connects the logic to a Market in order to pass market orders. The function returns a LiquidityProvider object */
    liquidityProvider(p: Market | {
        base: string;
        quote: string;
        bookOptions?: Market.BookOptions;
    }): Promise<LiquidityProvider>;
}
export default OfferLogic;
//# sourceMappingURL=offerLogic.d.ts.map
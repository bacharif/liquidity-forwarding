"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _TradeEventManagement_instances, _TradeEventManagement_rawIdToId;
Object.defineProperty(exports, "__esModule", { value: true });
const big_js_1 = __importDefault(require("big.js"));
const ethers = __importStar(require("ethers"));
const market_1 = __importDefault(require("../market"));
const unitCalculations_1 = __importDefault(require("./unitCalculations"));
const logger_1 = require("./logger");
class TradeEventManagement {
    constructor() {
        _TradeEventManagement_instances.add(this);
    }
    rawOfferToOffer(market, ba, raw) {
        const { outbound_tkn, inbound_tkn } = market.getOutboundInbound(ba);
        const gives = outbound_tkn.fromUnits(raw.gives);
        const wants = inbound_tkn.fromUnits(raw.wants);
        const { baseVolume } = market_1.default.getBaseQuoteVolumes(ba, gives, wants);
        const price = market_1.default.getPrice(ba, gives, wants);
        return {
            id: __classPrivateFieldGet(this, _TradeEventManagement_instances, "m", _TradeEventManagement_rawIdToId).call(this, raw.id),
            prev: __classPrivateFieldGet(this, _TradeEventManagement_instances, "m", _TradeEventManagement_rawIdToId).call(this, raw.prev),
            gasprice: raw.gasprice.toNumber(),
            maker: raw.maker,
            gasreq: raw.gasreq.toNumber(),
            gives: gives,
            wants: wants,
            volume: baseVolume,
            price: price,
        };
    }
    createSummaryFromEvent(event, got, gave, partialFillFunc) {
        return {
            got: got.fromUnits(event.args.takerGot),
            gave: gave.fromUnits(event.args.takerGave),
            partialFill: partialFillFunc(event.args.takerGot.add(event.args.feePaid ?? ethers.BigNumber.from(0)), event.args.takerGave),
            bounty: unitCalculations_1.default.fromUnits(event.args.penalty, 18),
            feePaid: "feePaid" in event.args
                ? unitCalculations_1.default.fromUnits(event.args.feePaid, 18)
                : (0, big_js_1.default)(0),
        };
    }
    createSummaryFromOrderCompleteEvent(evt, got, gave, partialFillFunc) {
        return this.createSummaryFromEvent(evt, got, gave, partialFillFunc);
    }
    createSuccessFromEvent(evt, got, gave) {
        const success = {
            offerId: evt.args.id.toNumber(),
            got: got.fromUnits(evt.args.takerWants),
            gave: gave.fromUnits(evt.args.takerGives),
        };
        return success;
    }
    createTradeFailureFromEvent(evt, got, gave) {
        const tradeFailure = {
            offerId: evt.args.id.toNumber(),
            reason: evt.args.mgvData,
            FailToDeliver: got.fromUnits(evt.args.takerWants),
            volumeGiven: gave.fromUnits(evt.args.takerGives),
        };
        return tradeFailure;
    }
    createPosthookFailureFromEvent(evt) {
        const posthookFailure = {
            offerId: evt.args.offerId.toNumber(),
            reason: evt.args.posthookData,
        };
        return posthookFailure;
    }
    createOfferWriteFromEvent(market, evt) {
        // ba can be both since we get offer writes both from updated orders and from posting a resting order, where the outbound is what taker gives
        let ba = "asks";
        let { outbound_tkn, inbound_tkn } = market.getOutboundInbound(ba);
        // If no match, try flipping
        if (outbound_tkn.address != evt.args.outbound_tkn) {
            ba = "bids";
            const bidsOutIn = market.getOutboundInbound(ba);
            outbound_tkn = bidsOutIn.outbound_tkn;
            inbound_tkn = bidsOutIn.inbound_tkn;
        }
        if (outbound_tkn.address != evt.args.outbound_tkn ||
            inbound_tkn.address != evt.args.inbound_tkn) {
            logger_1.logger.debug("OfferWrite for unknown market!", {
                contextInfo: "tradeEventManagement",
                base: market.base.name,
                quote: market.quote.name,
                data: {
                    outbound_tkn: evt.args.outbound_tkn,
                    inbound_tkn: evt.args.inbound_tkn,
                },
            });
            return null;
        }
        return { ba, offer: this.rawOfferToOffer(market, ba, evt.args) };
    }
    createSummaryFromOrderSummaryEvent(evt, got, gave, partialFillFunc) {
        return this.createSummaryFromEvent({
            args: {
                takerGot: evt.args.takerGot,
                takerGave: evt.args.takerGave,
                penalty: evt.args.bounty,
                feePaid: evt.args.fee,
            },
        }, got, gave, partialFillFunc);
    }
    createRestingOrderFromEvent(ba, evt, taker, currentRestingOrder, offerWrites) {
        if (evt.args.owner === taker) {
            ba = ba === "bids" ? "asks" : "bids";
            currentRestingOrder =
                offerWrites.find((x) => x.ba == ba && x.offer.id === __classPrivateFieldGet(this, _TradeEventManagement_instances, "m", _TradeEventManagement_rawIdToId).call(this, evt.args.offerId))?.offer ?? currentRestingOrder;
        }
        return currentRestingOrder;
    }
    createPartialFillFunc(fillWants, takerWants, takerGives) {
        return (takerGotWithFee, takerGave) => fillWants ? takerGotWithFee.lt(takerWants) : takerGave.lt(takerGives);
    }
    resultOfMangroveEventCore(receipt, evt, ba, partialFillFunc, result, market) {
        if (evt.args.taker && receipt.from !== evt.args.taker)
            return;
        const { outbound_tkn, inbound_tkn } = market.getOutboundInbound(ba);
        const name = "event" in evt ? evt.event : "name" in evt ? evt.name : null;
        switch (name) {
            case "OrderComplete": {
                //last OrderComplete is ours so it overrides previous summaries if any
                result.summary = this.createSummaryFromOrderCompleteEvent(evt, outbound_tkn, inbound_tkn, partialFillFunc);
                break;
            }
            case "OfferSuccess": {
                result.successes.push(this.createSuccessFromEvent(evt, outbound_tkn, inbound_tkn));
                break;
            }
            case "OfferFail": {
                result.tradeFailures.push(this.createTradeFailureFromEvent(evt, outbound_tkn, inbound_tkn));
                break;
            }
            case "PosthookFail": {
                result.posthookFailures.push(this.createPosthookFailureFromEvent(evt));
                break;
            }
            case "OfferWrite": {
                const offerWrite = this.createOfferWriteFromEvent(market, evt);
                if (offerWrite) {
                    result.offerWrites.push(offerWrite);
                }
                break;
            }
            default: {
                break;
            }
        }
    }
    resultOfMangroveOrderEventCore(receipt, evt, ba, partialFillFunc, result, market) {
        if (evt.args.taker && receipt.from !== evt.args.taker)
            return;
        const { outbound_tkn, inbound_tkn } = market.getOutboundInbound(ba);
        const name = "event" in evt ? evt.event : "name" in evt ? evt.name : null;
        switch (name) {
            case "OrderSummary": {
                //last OrderSummary is ours so it overrides previous summaries if any
                result.summary = this.createSummaryFromOrderSummaryEvent(evt, outbound_tkn, inbound_tkn, partialFillFunc);
                break;
            }
            case "NewOwnedOffer": {
                result.restingOrder = this.createRestingOrderFromEvent(ba, evt, receipt.from, result.restingOrder, result.offerWrites);
                break;
            }
            default: {
                break;
            }
        }
    }
    getContractEventsFromReceipt(receipt, contract) {
        const parseLogs = receipt.to === contract.address
            ? (events, logs) => events.filter((x) => x.address === contract.address)
            : (events, logs) => logs
                .filter((x) => x.address === contract.address)
                .map((l) => contract.interface.parseLog(l));
        return parseLogs(receipt.events, receipt.logs);
    }
    processMangroveEvents(result, receipt, ba, fillWants, wants, gives, market) {
        for (const evt of this.getContractEventsFromReceipt(receipt, market.mgv.contract)) {
            this.resultOfMangroveEventCore(receipt, evt, ba, this.createPartialFillFunc(fillWants, wants, gives), result, market);
        }
    }
    processMangroveOrderEvents(result, receipt, ba, fillWants, wants, gives, market) {
        for (const evt of this.getContractEventsFromReceipt(receipt, market.mgv.orderContract)) {
            this.resultOfMangroveOrderEventCore(receipt, evt, ba, this.createPartialFillFunc(fillWants, wants, gives), result, market);
        }
    }
}
_TradeEventManagement_instances = new WeakSet(), _TradeEventManagement_rawIdToId = function _TradeEventManagement_rawIdToId(rawId) {
    const id = rawId.toNumber();
    return id === 0 ? undefined : id;
};
exports.default = TradeEventManagement;
//# sourceMappingURL=tradeEventManagement.js.map
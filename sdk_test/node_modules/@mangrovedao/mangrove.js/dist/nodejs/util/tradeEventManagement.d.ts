import Big from "big.js";
import * as ethers from "ethers";
import { LogDescription } from "ethers/lib/utils";
import Market from "../market";
import MgvToken from "../mgvtoken";
import { OfferFailEvent, OfferSuccessEvent, OfferWriteEvent, OrderCompleteEvent, PosthookFailEvent } from "../types/typechain/Mangrove";
import { NewOwnedOfferEvent, OrderSummaryEvent } from "../types/typechain/MangroveOrder";
import { BaseContract, BigNumber } from "ethers";
declare type RawOfferData = {
    id: BigNumber;
    prev: BigNumber;
    gasprice: BigNumber;
    maker: string;
    gasreq: BigNumber;
    wants: BigNumber;
    gives: BigNumber;
};
declare class TradeEventManagement {
    #private;
    rawOfferToOffer(market: Market, ba: Market.BA, raw: RawOfferData): Market.OfferSlim;
    createSummaryFromEvent(event: {
        args: {
            takerGot: ethers.BigNumber;
            takerGave: ethers.BigNumber;
            penalty: ethers.BigNumber;
            feePaid?: ethers.BigNumber;
        };
    }, got: MgvToken, gave: MgvToken, partialFillFunc: (takerGotWithFee: ethers.BigNumber, takerGave: ethers.BigNumber) => boolean): Market.Summary;
    createSummaryFromOrderCompleteEvent(evt: OrderCompleteEvent, got: MgvToken, gave: MgvToken, partialFillFunc: (takerGotWithFee: ethers.BigNumber, takerGave: ethers.BigNumber) => boolean): Market.Summary;
    createSuccessFromEvent(evt: OfferSuccessEvent, got: MgvToken, gave: MgvToken): {
        offerId: number;
        got: Big;
        gave: Big;
    };
    createTradeFailureFromEvent(evt: OfferFailEvent, got: MgvToken, gave: MgvToken): {
        offerId: number;
        reason: string;
        FailToDeliver: Big;
        volumeGiven: Big;
    };
    createPosthookFailureFromEvent(evt: PosthookFailEvent): {
        offerId: number;
        reason: string;
    };
    createOfferWriteFromEvent(market: Market, evt: OfferWriteEvent): {
        ba: Market.BA;
        offer: Market.OfferSlim;
    };
    createSummaryFromOrderSummaryEvent(evt: OrderSummaryEvent, got: MgvToken, gave: MgvToken, partialFillFunc: (takerGotWithFee: ethers.BigNumber, takerGave: ethers.BigNumber) => boolean): Market.Summary;
    createRestingOrderFromEvent(ba: Market.BA, evt: NewOwnedOfferEvent, taker: string, currentRestingOrder: Market.OfferSlim, offerWrites: {
        ba: Market.BA;
        offer: Market.OfferSlim;
    }[]): Market.OfferSlim;
    createPartialFillFunc(fillWants: boolean, takerWants: ethers.ethers.BigNumber, takerGives: ethers.ethers.BigNumber): (takerGotWithFee: ethers.BigNumber, takerGave: ethers.BigNumber) => boolean;
    resultOfMangroveEventCore(receipt: ethers.ContractReceipt, evt: ethers.Event | LogDescription, ba: Market.BA, partialFillFunc: (takerGotWithFee: ethers.BigNumber, takerGave: ethers.BigNumber) => boolean, result: Market.OrderResult, market: Market): void;
    resultOfMangroveOrderEventCore(receipt: ethers.ContractReceipt, evt: ethers.Event | LogDescription, ba: Market.BA, partialFillFunc: (takerGotWithFee: ethers.BigNumber, takerGave: ethers.BigNumber) => boolean, result: Market.OrderResult, market: Market): void;
    getContractEventsFromReceipt(receipt: ethers.ContractReceipt, contract: BaseContract): ethers.ethers.Event[] | ethers.ethers.utils.LogDescription[];
    processMangroveEvents(result: Market.OrderResult, receipt: ethers.ContractReceipt, ba: Market.BA, fillWants: boolean, wants: ethers.BigNumber, gives: ethers.BigNumber, market: Market): void;
    processMangroveOrderEvents(result: Market.OrderResult, receipt: ethers.ContractReceipt, ba: Market.BA, fillWants: boolean, wants: ethers.BigNumber, gives: ethers.BigNumber, market: Market): void;
}
export default TradeEventManagement;
//# sourceMappingURL=tradeEventManagement.d.ts.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.devNodeInfos = exports.watchAllToyENSEntries = exports.connectToToyENSContract = exports.callDecimalsOn = void 0;
/* Utility function to:
 * Get all current entries of the Toy ENS contract
 * Subscribe to get all future modifications to its entries
 */
const ethers_1 = require("ethers");
const ToyENS = __importStar(require("./ToyENSCode"));
const types_1 = require("../types");
const multicallAbi = require("../constants/artifacts/Multicall2.json");
const multicallAddress = "0xdecaf1" + "0".repeat(34);
/* Call 'decimals' on all given addresses. */
const callDecimalsOn = async (provider, addresses) => {
    // ABI to get token decimals
    const ierc20 = types_1.typechain.IERC20__factory.createInterface();
    const decimalsData = ierc20.encodeFunctionData("decimals");
    /* Grab decimals for all contracts */
    const multicall = types_1.typechain.Multicall2__factory.connect(multicallAddress, provider);
    const args = addresses.map((addr) => {
        return { target: addr, callData: decimalsData };
    });
    const returnData = await multicall.callStatic.tryAggregate(false, args);
    const ret = returnData.map(({ success, returnData }) => {
        let decoded;
        if (success) {
            try {
                // if not a token, decoding will trigger the error encoded in returnData
                decoded = ierc20.decodeFunctionResult("decimals", returnData)[0];
            }
            catch (e) { }
        }
        return decoded;
    });
    return ret;
};
exports.callDecimalsOn = callDecimalsOn;
// Populate a ToyENS contract object
const connectToToyENSContract = (provider) => {
    return new ethers_1.ethers.Contract(ToyENS.address, ToyENS.abi, provider);
};
exports.connectToToyENSContract = connectToToyENSContract;
/* Fetch all Toy ENS entries, used to give contract addresses to Mangrove */
/* onSets is called at most once per block with the list of name,address pairs that were set during the block */
const watchAllToyENSEntries = async (provider, onSet) => {
    const ens = (0, exports.connectToToyENSContract)(provider);
    const initialBlock = await provider.getBlockNumber();
    if (typeof onSet !== "undefined") {
        ens.on("Set", async (name, address, evt) => {
            // Warning: may be incompatible with snapshot/revert to before initialization
            if (evt.blockNumber > initialBlock) {
                const [decimals] = await (0, exports.callDecimalsOn)(provider, [address]);
                onSet(name, address.toLowerCase(), decimals);
            }
        });
    }
    let names;
    let addresses;
    try {
        [names, addresses] = await ens.all();
    }
    catch (e) {
        return [];
    }
    // TODO: move decimals out of devNode and into mangrove.ts where it belongs
    const decimals = await (0, exports.callDecimalsOn)(provider, addresses);
    const contracts = names.map((name, index) => {
        return {
            name,
            address: addresses[index].toLowerCase(),
            decimals: decimals[index],
        };
    });
    return contracts;
};
exports.watchAllToyENSEntries = watchAllToyENSEntries;
exports.devNodeInfos = {
    anvil: {
        setCode: "anvil_setCode",
    },
    Hardhat: {
        setCode: "hardhat_setCode",
    },
    Ganache: {
        setCode: "evm_setAccountCode",
    },
};
class DevNode {
    constructor(provider) {
        this.multicallAddress = multicallAddress;
        if ("send" in provider) {
            this.provider = provider;
        }
        else {
            throw new Error("provider object has no send property; are you using JSON-RPC?");
        }
    }
    async clientVersion() {
        if (typeof this.web3ClientVersion === "undefined") {
            this.web3ClientVersion = await this.provider.send("web3_clientVersion", []);
        }
        return this.web3ClientVersion;
    }
    async clientType() {
        const version = await this.clientVersion();
        return version.split("/")[0];
    }
    async info() {
        const info = exports.devNodeInfos[await this.clientType()];
        if (typeof info === "undefined") {
            throw new Error(`No info for this node ${await this.clientVersion()}`);
        }
        return info;
    }
    async isDevNode() {
        return typeof exports.devNodeInfos[await this.clientType()] !== "undefined";
    }
    async setCode(address, newCode) {
        const method = (await this.info()).setCode;
        return await this.provider.send(method, [address, newCode]);
    }
    async hasCode(address) {
        const currentCode = await this.provider.send("eth_getCode", [
            address,
            "latest",
        ]);
        return currentCode !== "0x";
    }
    async setCodeIfAbsent(address, newCode) {
        if (!(await this.hasCode(address))) {
            return this.setCode(address, newCode);
        }
    }
    setToyENSCodeIfAbsent() {
        return this.setCodeIfAbsent(ToyENS.address, ToyENS.code);
    }
    setMulticallCodeIfAbsent() {
        return this.setCodeIfAbsent(multicallAddress, multicallAbi.deployedBytecode.object);
    }
    callDecimalsOn(addresses) {
        return (0, exports.callDecimalsOn)(this.provider, addresses);
    }
    connectToToyENSContract() {
        return (0, exports.connectToToyENSContract)(this.provider);
    }
    watchAllToyENSEntries(onSet) {
        return (0, exports.watchAllToyENSEntries)(this.provider, onSet);
    }
}
exports.default = DevNode;
//# sourceMappingURL=devNode.js.map
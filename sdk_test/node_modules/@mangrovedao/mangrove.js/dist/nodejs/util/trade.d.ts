import { ethers } from "ethers";
import Market from "../market";
import MgvToken from "../mgvtoken";
import { Bigish } from "../types";
import TradeEventManagement from "./tradeEventManagement";
import UnitCalculations from "./unitCalculations";
declare type SnipeUnitParams = {
    ba: Market.BA;
    targets: {
        offerId: number;
        takerWants: ethers.BigNumber;
        takerGives: ethers.BigNumber;
        gasLimit?: number;
    }[];
    fillWants?: boolean;
};
declare class Trade {
    mangroveUtils: UnitCalculations;
    tradeEventManagement: TradeEventManagement;
    getParamsForBuy(params: Market.TradeParams, baseToken: MgvToken, quoteToken: MgvToken): {
        wants: ethers.BigNumber;
        givesSlippageAmount: ethers.BigNumber;
        gives: ethers.BigNumber;
        fillWants: boolean;
    };
    getParamsForSell(params: Market.TradeParams, baseToken: MgvToken, quoteToken: MgvToken): {
        gives: ethers.BigNumber;
        wantsSlippageAmount: ethers.BigNumber;
        wants: ethers.BigNumber;
        fillWants: boolean;
    };
    validateSlippage: (slippage?: number) => number;
    comparePrices(price: Bigish, priceComparison: string, referencePrice: Bigish): any;
    isPriceBetter(price: Bigish, referencePrice: Bigish, ba: Market.BA): any;
    isPriceWorse(price: Bigish, referencePrice: Bigish, ba: Market.BA): any;
    /**
     * Market buy/sell order. Will attempt to buy/sell base token for quote tokens.
     * Params can be of the form:
     * - `{volume,price}`: buy `volume` base tokens for a max average price of `price`.
     * - `{total,price}` : buy as many base tokens as possible using up to `total` quote tokens, with a max average price of `price`.
     * - `{wants,gives,fillWants?}`: accept implicit max average price of `gives/wants`
     *
     * In addition, `slippage` defines an allowed slippage in % of the amount of quote token, and
     * `restingOrder` or `offerId` can be supplied to create a resting order or to snipe a specific order, e.g.,
     * to account for gas.
     *
     * Will stop if
     * - book is empty, or
     * - price no longer good, or
     * - `wants` tokens have been bought.
     *
     * @example
     * ```
     * const market = await mgv.market({base:"USDC",quote:"DAI"}
     * market.buy({volume: 100, price: '1.01'}) //use strings to be exact
     * ```
     */
    order(bs: Market.BS, params: Market.TradeParams, market: Market, overrides?: ethers.Overrides): Promise<{
        result: Promise<Market.OrderResult>;
        response: Promise<ethers.ContractTransaction>;
    }>;
    /**
     * Snipe specific offers.
     * Params are:
     * `targets`: an array of
     *    `offerId`: the offer to snipe
     *    `takerWants`: the amount of base token (for asks) or quote token (for bids) the taker wants
     *    `takerGives`: the amount of quote token (for asks) or base token (for bids) the take gives
     *    `gasLimit?`: the maximum gas requirement the taker will tolerate for that offer
     * `ba`: whether to snipe `asks` or `bids`
     * `fillWants?`: specifies whether you will buy at most `takerWants` (true), or you will buy as many tokens as possible as long as you don't spend more than `takerGives` (false).
     * `requireOffersToFail`: defines whether a successful offer will cause the call to fail without sniping anything.
     */
    snipe(params: Market.SnipeParams, market: Market, overrides?: ethers.Overrides): Promise<{
        result: Promise<Market.OrderResult>;
        response: Promise<ethers.ContractTransaction>;
    }>;
    /**
     * Gets parameters to send to functions `market.mgv.cleanerContract.collect` or `market.mgv.contract.snipes`.
     * Params are:
     * `targets`: an array of
     *    `offerId`: the offer to snipe
     *    `takerWants`: the amount of base token (for asks) or quote token (for bids) the taker wants
     *    `takerGives`: the amount of quote token (for asks) or base token (for bids) the take gives
     *    `gasLimit?`: the maximum gas requirement the taker will tolerate for that offer
     * `ba`: whether to snipe `asks` or `bids`
     * `fillWants?`: specifies whether you will buy at most `takerWants` (true), or you will buy as many tokens as possible as long as you don't spend more than `takerGives` (false).
     * `requireOffersToFail`: defines whether a successful offer will cause the call to fail without sniping anything.
     */
    getRawSnipeParams(params: Market.SnipeParams, market: Market, overrides?: ethers.Overrides): Promise<Market.RawSnipeParams>;
    /**
     * Low level Mangrove market order.
     * If `orderType` is `"buy"`, the base/quote market will be used,
     *
     * If `orderType` is `"sell"`, the quote/base market will be used,
     *
     * `fillWants` defines whether the market order stops immediately once `wants` tokens have been purchased or whether it tries to keep going until `gives` tokens have been spent.
     *
     * In addition, `slippage` defines an allowed slippage in % of the amount of quote token.
     *
     * Returns a promise for market order result after 1 confirmation.
     * Will throw on same conditions as ethers.js `transaction.wait`.
     */
    marketOrder({ wants, gives, orderType, fillWants, market, }: {
        wants: ethers.BigNumber;
        gives: ethers.BigNumber;
        orderType: Market.BS;
        fillWants: boolean;
        market: Market;
    }, overrides: ethers.Overrides): Promise<{
        result: Promise<Market.OrderResult>;
        response: Promise<ethers.ContractTransaction>;
    }>;
    responseToMarketOrderResult(response: Promise<ethers.ContractTransaction>, orderType: Market.BS, fillWants: boolean, wants: ethers.BigNumber, gives: ethers.BigNumber, market: Market): Promise<Market.OrderResult>;
    mangroveOrder({ wants, gives, orderType, fillWants, fillOrKill, expiryDate, restingParams, market, }: {
        wants: ethers.BigNumber;
        gives: ethers.BigNumber;
        orderType: Market.BS;
        fillWants: boolean;
        fillOrKill: boolean;
        expiryDate: number;
        restingParams: Market.RestingOrderParams;
        market: Market;
    }, overrides: ethers.Overrides): Promise<{
        result: Promise<Market.OrderResult>;
        response: Promise<ethers.ContractTransaction>;
    }>;
    responseToMangroveOrdeResult(response: Promise<ethers.ContractTransaction>, orderType: Market.BS, fillWants: boolean, wants: ethers.BigNumber, gives: ethers.BigNumber, market: Market): Promise<Market.OrderResult>;
    getRestingOrderParams(params: Market.RestingOrderParams): {
        provision: Bigish;
        postRestingOrder: boolean;
    };
    initialResult(receipt: ethers.ContractReceipt): Market.OrderResult;
    baToBs(ba: Market.BA): Market.BS;
    bsToBa(bs: Market.BS): Market.BA;
    /**
     * Gets parameters to send to functions `market.mgv.cleanerContract.collect` or `market.mgv.contract.snipes`.
     */
    getSnipesRawParamsFromUnitParams(unitParams: SnipeUnitParams, market: Market, overrides: ethers.Overrides): Promise<Market.RawSnipeParams>;
    /**
     * Low level sniping of `targets`.
     *
     * `requireOffersToFail`: if true, then a successful offer will cause the call to fail without sniping anything.
     *
     * Returns a promise for snipes result after 1 confirmation.
     * Will throw on same conditions as ethers.js `transaction.wait`.
     */
    snipesWithRawParameters(raw: Market.RawSnipeParams, market: Market, overrides: ethers.Overrides, requireOffersToFail?: boolean): Promise<{
        result: Promise<Market.OrderResult>;
        response: Promise<ethers.ContractTransaction>;
    }>;
    responseToSnipesResult(response: Promise<ethers.ContractTransaction>, raw: Market.RawSnipeParams, market: Market): Promise<Market.OrderResult>;
    /**
     * Low level sniping of `targets`.
     *
     * Returns a promise for snipes result after 1 confirmation.
     * Will throw on same conditions as ethers.js `transaction.wait`.
     */
    snipes(unitParams: SnipeUnitParams, market: Market, overrides: ethers.Overrides): Promise<{
        result: Promise<Market.OrderResult>;
        response: Promise<ethers.ContractTransaction>;
    }>;
}
export default Trade;
//# sourceMappingURL=trade.d.ts.map
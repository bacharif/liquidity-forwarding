import { ContractTransaction, ethers } from "ethers";
import { Market, MgvToken, Mangrove } from "../..";
import * as typechain from "../../types/typechain";
import { Provider, TransactionReceipt } from "@ethersproject/abstract-provider";
export declare type Account = {
    name: string;
    address: string;
    signer: ethers.Signer;
    connectedContracts: {
        mangrove: typechain.Mangrove;
        testMaker: typechain.SimpleTestMaker;
        tokenA: typechain.TestToken;
        tokenB: typechain.TestToken;
    };
};
export declare type Balances = {
    ether: ethers.BigNumber;
    tokenA: ethers.BigNumber;
    tokenB: ethers.BigNumber;
};
export declare const bidsAsks: Market.BA[];
export declare type AddressAndSigner = {
    address: string;
    signer: string;
};
export declare type Addresses = {
    mangrove: AddressAndSigner;
    testMaker: AddressAndSigner;
    tokenA: AddressAndSigner;
    tokenB: AddressAndSigner;
};
export declare const setConfig: (_mgv: Mangrove, accounts: any, _mgvAdmin?: Mangrove) => void;
export declare const getAddresses: () => Promise<Addresses>;
export declare const logAddresses: () => Promise<void>;
export declare type Contracts = {
    mangrove: typechain.Mangrove;
    testMaker: typechain.SimpleTestMaker;
    tokenA: typechain.TestToken;
    tokenB: typechain.TestToken;
};
export declare const getContracts: (signer: ethers.Signer) => Promise<Contracts>;
export declare enum AccountName {
    Deployer = "deployer",
    Cleaner = "cleaner",
    Maker = "maker"
}
export declare const getAccount: (name: AccountName) => Promise<Account>;
export declare const getAccountBalances: (account: Account, provider: Provider) => Promise<Balances>;
export declare const getBalances: (accounts: Account[], provider: Provider) => Promise<Map<string, Balances>>;
export declare const logBalances: (accounts: Account[], balancesBefore: Map<string, Balances>, balancesAfter: Map<string, Balances>) => Promise<void>;
export declare const getTokens: (market: Market, ba: Market.BA) => {
    inboundToken: MgvToken;
    outboundToken: MgvToken;
};
export declare type NewOffer = {
    market: Market;
    ba: Market.BA;
    maker: Account;
    wants?: ethers.BigNumberish;
    gives?: ethers.BigNumberish;
    gasreq?: ethers.BigNumberish;
    shouldFail?: boolean;
    shouldReturnData?: boolean;
    shouldRevert?: boolean;
};
export declare let isTrackingPolls: boolean;
/**
 * Await this when you want to wait for all events corresponding to the last sent tx to have been sent.
 */
export declare let eventsForLastTxHaveBeenGeneratedPromise: Promise<void>;
/**
 * Waits for last tx to be generated and optionally the market's books to be synced.
 * WARNING: If `market` is given, then `SetGasbase` events (with no actual change to gasbase)
 * are provoked to gage semibook-states. Handle accordingly in your test code.
 * @param market wait for books in this market to be in sync.
 */
export declare function waitForBooksForLastTx(market?: Market): Promise<void>;
/**
 * Call this to enable tracking of whether the last transaction sent by this library has been mined and polled.
 */
export declare const initPollOfTransactionTracking: (provider: Provider) => void;
/**
 * Call this disable tracking of whether the last transaction sent by this library has been mined and polled.
 */
export declare const stopPollOfTransactionTracking: () => void;
/**
 * Use this to await transactions. In addition to convenience,
 * it allows us to track when events for the last tx have been generated.
 * NB: Only works when this is awaited before sending more tx's.
 */
export declare function waitForTransaction(txPromise: Promise<ContractTransaction>): Promise<TransactionReceipt>;
export declare const postNewOffer: ({ market, ba, maker, wants, gives, gasreq, shouldFail, shouldRevert, }: NewOffer) => Promise<void>;
export declare const postNewRevertingOffer: (market: Market, ba: Market.BA, maker: Account) => Promise<void>;
export declare const postNewSucceedingOffer: (market: Market, ba: Market.BA, maker: Account) => Promise<void>;
export declare const postNewFailingOffer: (market: Market, ba: Market.BA, maker: Account) => Promise<void>;
export declare const setMgvGasPrice: (gasPrice: ethers.BigNumberish) => Promise<void>;
export declare const mint: (token: MgvToken, receiver: Account, amount: number) => Promise<void>;
export declare const approveMgv: (token: MgvToken, owner: Account, amount: number) => Promise<void>;
export declare const approve: (token: MgvToken, owner: Account, spenderAddress: string, amount: number) => Promise<void>;
//# sourceMappingURL=mgvIntegrationTestUtil.d.ts.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.approve = exports.approveMgv = exports.mint = exports.setMgvGasPrice = exports.postNewFailingOffer = exports.postNewSucceedingOffer = exports.postNewRevertingOffer = exports.postNewOffer = exports.waitForTransaction = exports.stopPollOfTransactionTracking = exports.initPollOfTransactionTracking = exports.waitForBooksForLastTx = exports.eventsForLastTxHaveBeenGeneratedPromise = exports.isTrackingPolls = exports.getTokens = exports.logBalances = exports.getBalances = exports.getAccountBalances = exports.getAccount = exports.AccountName = exports.getContracts = exports.logAddresses = exports.getAddresses = exports.setConfig = exports.bidsAsks = void 0;
// TODO do not distribute in browser version
// Utility functions for writing integration tests against Mangrove.
const ethers_1 = require("ethers");
const __1 = require("../..");
const typechain = __importStar(require("../../types/typechain"));
const util_1 = require("../../util");
exports.bidsAsks = ["bids", "asks"];
let addresses;
let mgv;
let mgvAdmin;
let signers = {};
// With the removal of hardhat, there is no "default chain" anymore
// (it used to be implicit since we ran the ethereum local server in-process).
// Now getting contract addresses requires a known network.
// We minimally disrupt this library and just add a global "mangrove"
// to be set early in the tests.
// TODO: Remove this hack, and either remove this lib or add an `mgv` param everywhere.
const setConfig = (_mgv, accounts, _mgvAdmin) => {
    mgv = _mgv;
    mgvAdmin = _mgvAdmin;
    for (const [name, { key }] of Object.entries(accounts)) {
        signers[name] = new ethers_1.ethers.Wallet(key, mgv.provider);
    }
};
exports.setConfig = setConfig;
const getAddresses = async () => {
    if (!addresses) {
        const mg = await mgv.contract;
        const tm = await __1.Mangrove.typechain.SimpleTestMaker__factory.connect(mgv.getAddress("SimpleTestMaker"), mgv.signer);
        const ta = mgv.token("TokenA").contract;
        const tb = mgv.token("TokenB").contract;
        addresses = {
            mangrove: { address: mg.address, signer: await mg.signer.getAddress() },
            testMaker: { address: tm.address, signer: await tm.signer.getAddress() },
            tokenA: { address: ta.address, signer: await ta.signer.getAddress() },
            tokenB: { address: tb.address, signer: await tb.signer.getAddress() },
        };
    }
    return addresses;
};
exports.getAddresses = getAddresses;
const logAddresses = async () => {
    console.group("Addresses");
    const addresses = await (0, exports.getAddresses)();
    console.table(addresses);
    console.groupEnd();
};
exports.logAddresses = logAddresses;
const getContracts = async (signer) => {
    const addresses = await (0, exports.getAddresses)();
    return {
        mangrove: typechain.Mangrove__factory.connect(addresses.mangrove.address, signer),
        testMaker: typechain.SimpleTestMaker__factory.connect(addresses.testMaker.address, signer),
        tokenA: typechain.TestToken__factory.connect(addresses.tokenA.address, signer),
        tokenB: typechain.TestToken__factory.connect(addresses.tokenB.address, signer),
    };
};
exports.getContracts = getContracts;
var AccountName;
(function (AccountName) {
    AccountName["Deployer"] = "deployer";
    AccountName["Cleaner"] = "cleaner";
    AccountName["Maker"] = "maker";
})(AccountName = exports.AccountName || (exports.AccountName = {}));
const getAccount = async (name) => {
    const signer = signers[name];
    if (!signer) {
        throw new Error(`Unknown signer name ${name}`);
    }
    return {
        name: name,
        address: signer.address,
        signer: signer,
        connectedContracts: await (0, exports.getContracts)(signer),
    };
};
exports.getAccount = getAccount;
const getAccountBalances = async (account, provider) => {
    return {
        ether: await provider.getBalance(account.address),
        tokenA: await account.connectedContracts.tokenA.balanceOf(account.address),
        tokenB: await account.connectedContracts.tokenB.balanceOf(account.address),
    };
};
exports.getAccountBalances = getAccountBalances;
const getBalances = async (accounts, provider) => {
    const balances = new Map();
    for (const account of accounts) {
        balances.set(account.name, await (0, exports.getAccountBalances)(account, provider));
    }
    return balances;
};
exports.getBalances = getBalances;
const logBalances = async (accounts, balancesBefore, balancesAfter) => {
    const accountBalancesTable = []; // [(name?, address?, ether|token|..., before, after, change)]
    for (const account of accounts) {
        const before = balancesBefore.get(account.name);
        const after = balancesAfter.get(account.name);
        if (!before || !after) {
            continue;
        }
        accountBalancesTable.push({
            Name: account.name,
            Address: account.address,
            Currency: "ether",
            Before: before.ether.toString(),
            After: after.ether.toString(),
            Change: after.ether.sub(before.ether).toString(),
        });
        accountBalancesTable.push({
            Name: "",
            Address: "",
            Currency: "TokenA",
            Before: before.tokenA.toString(),
            After: after.tokenA.toString(),
            Change: after.tokenA.sub(before.tokenA).toString(),
        });
        accountBalancesTable.push({
            Name: "",
            Address: "",
            Currency: "TokenB",
            Before: before.tokenB.toString(),
            After: after.tokenB.toString(),
            Change: after.tokenB.sub(before.tokenB).toString(),
        });
    }
    console.group("Balances");
    console.table(accountBalancesTable, [
        "Name",
        "Address",
        "Currency",
        "Before",
        "After",
        "Change",
    ]);
    console.groupEnd();
};
exports.logBalances = logBalances;
const getTokens = (market, ba) => {
    return {
        inboundToken: ba === "asks" ? market.quote : market.base,
        outboundToken: ba === "asks" ? market.base : market.quote,
    };
};
exports.getTokens = getTokens;
exports.isTrackingPolls = false;
let providerCopy;
let lastTxReceipt;
let awaitedPollId;
let eventsForLastTxHaveBeenGeneratedDeferred;
/**
 * Waits for last tx to be generated and optionally the market's books to be synced.
 * WARNING: If `market` is given, then `SetGasbase` events (with no actual change to gasbase)
 * are provoked to gage semibook-states. Handle accordingly in your test code.
 * @param market wait for books in this market to be in sync.
 */
async function waitForBooksForLastTx(market) {
    // Wait for txs so we can get the right block number for them
    await eventsForLastTxHaveBeenGenerated();
    if (!exports.isTrackingPolls) {
        throw Error("call initPollOfTransactionTracking before trying to await waitForBooksForLastTx");
    }
    if (market) {
        /*
          Provoke and then listen specifically for SetGasbase events for each semibook.
          As events are received in the order over they are produced over websockets, when
          these SetGasbase-events are processed by the semibooks, we know that any
          previously emitted events have also been processed
        */
        let asksPromiseResolve;
        const askPromise = new Promise((resolve) => {
            asksPromiseResolve = resolve;
        });
        // set up semibook subscribers
        const asksCB = (cbArg, bookEvent) => {
            if (cbArg.ba === "asks" && bookEvent.name === "SetGasbase") {
                asksPromiseResolve();
            }
        };
        let bidsPromiseResolve;
        const bidsPromise = new Promise((resolve) => {
            bidsPromiseResolve = resolve;
        });
        const bidsCB = (cbArg, bookEvent) => {
            if (cbArg.ba === "bids" && bookEvent.name === "SetGasbase") {
                bidsPromiseResolve();
            }
        };
        market.subscribe(asksCB);
        market.subscribe(bidsCB);
        // we provoke both semibooks to process events by
        // sending a setGasbase events to both books
        const localConfig = await market.config();
        const asksGasBase = localConfig.asks.offer_gasbase;
        const bidsGasBase = localConfig.bids.offer_gasbase;
        if (!mgvAdmin) {
            throw Error("_mgvAdmin is null. Setup _mgvAdmin via setConfig!");
        }
        await waitForTransaction(mgvAdmin.contract.setGasbase(market.base.address, market.quote.address, asksGasBase));
        await waitForTransaction(mgvAdmin.contract.setGasbase(market.quote.address, market.base.address, bidsGasBase));
        // and now wait for both
        await Promise.all([askPromise, bidsPromise])
            .then(() => { }, (reason) => {
            throw new Error(`Error in waiting for synthetic SetGasbase events in waitForBooksForLastTx: ${reason}`);
        })
            .finally(() => {
            market.unsubscribe(asksCB);
            market.unsubscribe(bidsCB);
        });
    }
}
exports.waitForBooksForLastTx = waitForBooksForLastTx;
function eventsForLastTxHaveBeenGenerated() {
    if (!exports.eventsForLastTxHaveBeenGeneratedPromise) {
        throw Error("call initPollOfTransactionTracking before trying to await eventsForLastTxHaveBeenGenerated");
    }
    return exports.eventsForLastTxHaveBeenGeneratedPromise;
}
// Handler for ethers.js "poll" events:
// "emitted during each poll cycle after `blockNumber` is updated (if changed) and
// before any other events (if any) are emitted during the poll loop"
// https://docs.ethers.io/v5/single-page/#/v5/api/providers/provider/
function pollEventHandler(pollId, blockNumber) {
    if (!exports.isTrackingPolls)
        return;
    if (lastTxReceipt !== undefined && blockNumber >= lastTxReceipt.blockNumber) {
        awaitedPollId = pollId;
        lastTxReceipt = undefined;
    }
}
// Handler for ethers.js "poll" events:
// "emitted after all events from a polling loop are emitted"
// https://docs.ethers.io/v5/single-page/#/v5/api/providers/provider/
function didPollEventHandler(pollId) {
    if (!exports.isTrackingPolls)
        return;
    if (pollId === awaitedPollId) {
        awaitedPollId = undefined;
        // setImmediate(() => setImmediate(() => eventsForLastTxHaveBeenGeneratedDeferred.resolve()));
        // TODO: This hack seems to work, but a more direct solution would be great
        // NB: We tried various uses of setImmediately, but couldn't get it to work.
        setTimeout(() => eventsForLastTxHaveBeenGeneratedDeferred.resolve(), 1);
    }
}
/**
 * Call this to enable tracking of whether the last transaction sent by this library has been mined and polled.
 */
const initPollOfTransactionTracking = (provider) => {
    exports.isTrackingPolls = true;
    providerCopy = provider;
    provider.on("poll", pollEventHandler);
    provider.on("didPoll", didPollEventHandler);
};
exports.initPollOfTransactionTracking = initPollOfTransactionTracking;
/**
 * Call this disable tracking of whether the last transaction sent by this library has been mined and polled.
 */
const stopPollOfTransactionTracking = () => {
    exports.isTrackingPolls = false;
    providerCopy.off("poll", pollEventHandler);
    providerCopy.off("didPoll", didPollEventHandler);
};
exports.stopPollOfTransactionTracking = stopPollOfTransactionTracking;
/**
 * Use this to await transactions. In addition to convenience,
 * it allows us to track when events for the last tx have been generated.
 * NB: Only works when this is awaited before sending more tx's.
 */
async function waitForTransaction(txPromise) {
    awaitedPollId = undefined;
    lastTxReceipt = undefined;
    const tx = await txPromise;
    lastTxReceipt = await tx.wait();
    if (exports.isTrackingPolls) {
        eventsForLastTxHaveBeenGeneratedDeferred = new util_1.Deferred();
        exports.eventsForLastTxHaveBeenGeneratedPromise =
            eventsForLastTxHaveBeenGeneratedDeferred.promise;
    }
    return lastTxReceipt;
}
exports.waitForTransaction = waitForTransaction;
// By default, a new offer will succeed
const postNewOffer = async ({ market, ba, maker, wants = 1, gives = 1000000, gasreq = 5e4, shouldFail = false, shouldRevert = false, }) => {
    const { inboundToken, outboundToken } = (0, exports.getTokens)(market, ba);
    // we start by making sure that Mangrove is approved (for infinite fund withdrawal)
    // and that we have funds (going below the minting limit for ERC20's)
    await waitForTransaction(maker.connectedContracts.testMaker.approveMgv(outboundToken.address, ethers_1.ethers.constants.MaxUint256));
    await rawMint(outboundToken, maker.connectedContracts.testMaker.address, ethers_1.BigNumber.from(gives).mul(2));
    await waitForTransaction(maker.connectedContracts.testMaker.shouldFail(shouldFail));
    await waitForTransaction(maker.connectedContracts.testMaker.shouldRevert(shouldRevert));
    await waitForTransaction(maker.connectedContracts.testMaker["newOffer(address,address,uint256,uint256,uint256,uint256)"](outboundToken.address, inboundToken.address, wants, gives, gasreq, 1)); // (base address, quote address, wants, gives, gasreq, pivotId)
};
exports.postNewOffer = postNewOffer;
const postNewRevertingOffer = async (market, ba, maker) => {
    await (0, exports.postNewOffer)({
        market,
        ba,
        maker,
        wants: 1,
        gives: 1000000,
        shouldRevert: true,
    });
};
exports.postNewRevertingOffer = postNewRevertingOffer;
const postNewSucceedingOffer = async (market, ba, maker) => {
    await (0, exports.postNewOffer)({ market, ba, maker });
};
exports.postNewSucceedingOffer = postNewSucceedingOffer;
const postNewFailingOffer = async (market, ba, maker) => {
    await (0, exports.postNewOffer)({ market, ba, maker, shouldFail: true });
};
exports.postNewFailingOffer = postNewFailingOffer;
const setMgvGasPrice = async (gasPrice) => {
    const deployer = await (0, exports.getAccount)(AccountName.Deployer);
    await waitForTransaction(deployer.connectedContracts.mangrove.setGasprice(gasPrice));
};
exports.setMgvGasPrice = setMgvGasPrice;
const rawMint = async (token, receiverAddress, internalAmount) => {
    const deployer = await (0, exports.getAccount)(AccountName.Deployer);
    switch (token.name) {
        case "TokenA":
            await waitForTransaction(deployer.connectedContracts.tokenA.mint(receiverAddress, internalAmount));
            break;
        case "TokenB":
            await waitForTransaction(deployer.connectedContracts.tokenB.mint(receiverAddress, internalAmount));
            break;
    }
};
const mint = async (token, receiver, amount) => {
    await rawMint(token, receiver.address, token.toUnits(amount));
};
exports.mint = mint;
const approveMgv = async (token, owner, amount) => {
    const addresses = await (0, exports.getAddresses)();
    await (0, exports.approve)(token, owner, addresses.mangrove.address, amount);
};
exports.approveMgv = approveMgv;
const approve = async (token, owner, spenderAddress, amount) => {
    switch (token.name) {
        case "TokenA":
            await waitForTransaction(owner.connectedContracts.tokenA.approve(spenderAddress, token.toUnits(amount)));
            break;
        case "TokenB":
            await waitForTransaction(owner.connectedContracts.tokenB.approve(spenderAddress, token.toUnits(amount)));
            break;
    }
};
exports.approve = approve;
//# sourceMappingURL=mgvIntegrationTestUtil.js.map
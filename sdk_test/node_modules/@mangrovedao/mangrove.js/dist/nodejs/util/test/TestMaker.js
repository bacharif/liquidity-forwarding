"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _TestMaker_instances, _TestMaker_constructPromise;
Object.defineProperty(exports, "__esModule", { value: true });
const ethers = __importStar(require("ethers"));
const market_1 = __importDefault(require("../../market"));
const mangrove_1 = __importDefault(require("../../mangrove"));
const prettyPrint_1 = __importDefault(require("../prettyPrint"));
const __1 = require("../..");
const typechain = __importStar(require("../../types/typechain"));
const mgvIntegrationTestUtil_1 = require("./mgvIntegrationTestUtil");
/* Prevent directly calling Mangrove constructor
   use Mangrove.connect to make sure the network is reached during construction */
let canConstructTestMaker = false;
let PROVISION_AMOUNT_IN_ETHERS = 2;
class TestMaker {
    constructor(p) {
        _TestMaker_instances.add(this);
        this.prettyP = new prettyPrint_1.default();
        if (!canConstructTestMaker) {
            throw Error("TestMaker must be initialized async with Market.create (constructors cannot be async)");
        }
        this.mgv = p.mgv;
        this.contract = typechain.SimpleTestMaker__factory.connect(p.address, p.mgv.signer);
        this.market = p.market;
    }
    static async create(p) {
        const baseAddress = p.mgv.getAddress(p.base);
        const quoteAddress = p.mgv.getAddress(p.quote);
        const contract = await new typechain.SimpleTestMaker__factory(p.mgv.signer).deploy(p.mgv.address, baseAddress, quoteAddress);
        await contract.deployTransaction.wait();
        const amount = mangrove_1.default.toUnits(PROVISION_AMOUNT_IN_ETHERS, 18);
        const tx = await contract.provisionMgv(amount, { value: amount });
        await tx.wait();
        const market = await market_1.default.connect(p);
        canConstructTestMaker = true;
        const testMaker = new TestMaker({
            mgv: p.mgv,
            market,
            address: contract.address,
        });
        canConstructTestMaker = false;
        return testMaker;
    }
    async newOffer(p, overrides = {}) {
        const defaults = {
            shouldRevert: false,
            executeData: "executeData",
            gasreq: 100000,
            gasprice: 0,
        };
        p = { ...defaults, ...p };
        const { wants, gives, price, fund } = __1.LiquidityProvider.normalizeOfferParams(p);
        const { outbound_tkn, inbound_tkn } = this.market.getOutboundInbound(p.ba);
        // ensure mangrove is approved
        await (0, mgvIntegrationTestUtil_1.waitForTransaction)(this.contract.approveMgv(outbound_tkn.address, ethers.constants.MaxUint256));
        await (0, mgvIntegrationTestUtil_1.waitForTransaction)(this.contract.approveMgv(inbound_tkn.address, ethers.constants.MaxUint256));
        //TODO impersonate admin/someone with tokens
        await (0, mgvIntegrationTestUtil_1.waitForTransaction)(typechain.TestToken__factory.connect(outbound_tkn.address, this.mgv.signer).mint(this.contract.address, ethers.BigNumber.from(gives)));
        const payableOverrides = __1.LiquidityProvider.optValueToPayableOverride(overrides, fund);
        const amount = payableOverrides.value ?? 0;
        const offerData = {
            shouldRevert: p.shouldRevert,
            executeData: p.executeData,
        };
        const pivot = (await this.market.getPivotId(p.ba, price)) ?? 0;
        const txPromise = this.contract["newOfferWithFunding(address,address,uint256,uint256,uint256,uint256,uint256,uint256,(bool,string))"](this.market.base.address, this.market.quote.address, inbound_tkn.toUnits(wants), outbound_tkn.toUnits(gives), p.gasreq, p.gasprice, pivot, amount, offerData, payableOverrides);
        return __classPrivateFieldGet(this, _TestMaker_instances, "m", _TestMaker_constructPromise).call(this, this.market, (_cbArg, _bookEevnt, _ethersLog) => ({
            id: _cbArg.offerId,
            pivot: pivot,
            event: _ethersLog,
        }), txPromise, (cbArg) => cbArg.type === "OfferWrite");
    }
    /** Post a new ask */
    newAsk(p, overrides = {}) {
        return this.newOffer({ ba: "asks", ...p }, overrides);
    }
    /** Post a new bid */
    newBid(p, overrides = {}) {
        return this.newOffer({ ba: "bids", ...p }, overrides);
    }
    /** List all of the maker's asks in the cache */
    asks() {
        return this.market
            .getBook()
            .asks.iter()
            .filter((ofr) => ofr.maker === this.contract.address)
            .toArray();
    }
    /** List all of the maker's bids in the cache */
    bids() {
        return this.market
            .getBook()
            .bids.iter()
            .filter((ofr) => ofr.maker === this.contract.address)
            .toArray();
    }
    /** Pretty prints the current state of the asks for the maker */
    consoleAsks(filter) {
        this.prettyP.consoleOffers(this.asks(), filter);
    }
    /** Pretty prints the current state of the bids for the maker */
    consoleBids(filter) {
        this.prettyP.consoleOffers(this.bids(), filter);
    }
}
_TestMaker_instances = new WeakSet(), _TestMaker_constructPromise = function _TestMaker_constructPromise(market, cb, txPromise, filter) {
    let promiseResolve;
    let promiseReject;
    const promise = new Promise((resolve, reject) => {
        promiseResolve = resolve;
        promiseReject = reject;
    });
    // catch rejections of the txPromise and reject returned promise
    txPromise.catch((e) => promiseReject(e));
    const callback = async (cbArg, bookEvent, ethersLog) => {
        const txHash = (await txPromise).hash;
        const logTxHash = ethersLog.transactionHash;
        if (txHash === logTxHash && filter(cbArg)) {
            promiseResolve(cb(cbArg, bookEvent, ethersLog));
        }
    };
    market.subscribe(callback); // TODO: subscribe/once ?
    return promise.finally(() => market.unsubscribe(callback));
};
exports.default = TestMaker;
//# sourceMappingURL=TestMaker.js.map
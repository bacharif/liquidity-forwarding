"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers = __importStar(require("ethers"));
const market_1 = __importDefault(require("./market"));
const types_1 = require("./types");
const _1 = require(".");
/**
 * The OfferLogic class connects to a Maker contract
 */
class OfferLogic {
    constructor(mgv, logic, signer) {
        this.mgv = mgv;
        this.address = logic;
        this.contract = types_1.typechain.ILiquidityProvider__factory.connect(logic, signer ? signer : this.mgv.signer);
    }
    static async deploy(mgv) {
        const contract = await new types_1.typechain[`OfferMaker__factory`](mgv.signer).deploy(mgv.address, ethers.constants.AddressZero, await mgv.signer.getAddress());
        await contract.deployTransaction.wait();
        return contract.address;
    }
    /**
     * @note Returns this logic's router. If logic has no router this call will return `undefined`
     * @returns the router ethers.js contract responding to the `AbstractRouter` abi.
     */
    async router() {
        const router_address = await this.contract.router();
        if (router_address != ethers.constants.AddressZero) {
            return types_1.typechain.AbstractRouter__factory.connect(router_address, this.mgv.signer);
        }
    }
    /**
     * @note Approves the logic to spend `token`s on signer's behalf.
     * This has to be done for each token the signer's wishes to ask or bid for.
     * @param arg optional `arg.amount` can be used if one wishes to approve a finite amount
     */
    async approveToken(tokenName, arg = {}) {
        const router = await this.router();
        const token = this.mgv.token(tokenName);
        if (router) {
            // LP's logic is using a router to manage its liquidity
            return token.approve(router.address, arg);
        }
        else {
            // LP's logic is doing the routing itself
            return token.approve(this.address, arg);
        }
    }
    /**@note returns logic's allowance to trade `tokenName` on signer's behalf */
    async allowance(tokenName) {
        const router = await this.router();
        const token = this.mgv.token(tokenName);
        if (router) {
            return token.allowance({
                owner: await this.mgv.signer.getAddress(),
                spender: router.address,
            });
        }
        else {
            return token.allowance({
                owner: await this.mgv.signer.getAddress(),
                spender: this.address,
            });
        }
    }
    // returns a new `OfferLogic` object with a different signer or provider connected to its ethers.js `contract`
    connect(sOp) {
        return new OfferLogic(this.mgv, this.contract.address, sOp);
    }
    async offerGasreq() {
        const gr = await this.contract.offerGasreq();
        return gr.toNumber();
    }
    setAdmin(newAdmin, overrides = {}) {
        const accessControlled = types_1.typechain.AccessControlled__factory.connect(this.address, this.mgv.signer);
        return accessControlled.setAdmin(newAdmin, overrides);
    }
    admin() {
        const accessControlled = types_1.typechain.AccessControlled__factory.connect(this.address, this.mgv.signer);
        return accessControlled.admin();
    }
    /**
     * @note (contract admin action) activates logic
     * @param tokenNames the names of the tokens one wishes the logic to trade
     * */
    activate(tokenNames, overrides = {}) {
        const tokenAddresses = tokenNames.map((tokenName) => this.mgv.token(tokenName).address);
        return this.contract.activate(tokenAddresses, overrides);
    }
    // todo look in the tx receipt for the `Debit(maker, amount)` log emitted by mangrove in order to returned a value to user
    retractOffer(outbound_tkn, inbound_tkn, id, deprovision, overrides) {
        return this.contract.retractOffer(this.mgv.token(outbound_tkn).address, this.mgv.token(inbound_tkn).address, id, deprovision, overrides);
    }
    /** Withdraw from the OfferLogic's ether balance on Mangrove to the sender's account */
    /** tx will revert is signer is not the admin of the OfferLogic onchain contract */
    async withdrawFromMangrove(amount, overrides = {}) {
        return this.contract.withdrawFromMangrove(this.mgv.toUnits(amount, 18), await this.mgv.signer.getAddress(), overrides);
    }
    /** Connects the logic to a Market in order to pass market orders. The function returns a LiquidityProvider object */
    async liquidityProvider(p) {
        if (p instanceof market_1.default) {
            return new _1.LiquidityProvider({
                mgv: this.mgv,
                logic: this,
                market: p,
            });
        }
        else {
            return new _1.LiquidityProvider({
                mgv: this.mgv,
                logic: this,
                market: await this.mgv.market(p),
            });
        }
    }
}
exports.default = OfferLogic;
//# sourceMappingURL=offerLogic.js.map
import { LiquidityProvider, Market, MgvToken, OfferLogic } from ".";
import * as eth from "./eth";
import DevNode from "./util/devNode";
import { Bigish, Provider, Signer, typechain } from "./types";
import { ApproveArgs } from "./mgvtoken";
import Big from "big.js";
import * as ethers from "ethers";
import type { Awaited } from "ts-essentials";
declare namespace Mangrove {
    type RawConfig = Awaited<ReturnType<typechain.Mangrove["functions"]["configInfo"]>>;
    type LocalConfig = {
        active: boolean;
        fee: number;
        density: Big;
        offer_gasbase: number;
        lock: boolean;
        best: number | undefined;
        last: number | undefined;
    };
    type GlobalConfig = {
        monitor: string;
        useOracle: boolean;
        notify: boolean;
        gasprice: number;
        gasmax: number;
        dead: boolean;
    };
    type OpenMarketInfo = {
        base: {
            address: string;
            symbol: string;
            decimals: number;
        };
        quote: {
            address: string;
            symbol: string;
            decimals: number;
        };
        asksConfig: LocalConfig;
        bidsConfig: LocalConfig;
    };
}
declare class Mangrove {
    provider: Provider;
    signer: Signer;
    network: eth.ProviderNetwork;
    _readOnly: boolean;
    address: string;
    contract: typechain.Mangrove;
    readerContract: typechain.MgvReader;
    cleanerContract: typechain.MgvCleaner;
    multicallContract: typechain.Multicall2;
    orderContract: typechain.MangroveOrderEnriched;
    static typechain: typeof typechain;
    static addresses: {
        mainnet: {};
        rinkeby: {};
        goerli: {};
        kovan: {};
        ropsten: {};
        maticmum: {
            WETH: string;
            WMATIC: string;
            USDC: string;
            DAI: string;
            Multicall2: string;
        };
        local: {};
        matic: {
            DAI: string;
            USDC: string;
            WETH: string;
            Multicall2: string;
        };
    };
    /**
     * Creates an instance of the Mangrove Typescript object
     *
     * @param {object} [options] Optional provider options.
     *
     * @example
     * ```
     * const mgv = await require('mangrove.js').connect(options); // web browser
     * ```
     *
     * if options is a string `s`, it is considered to be {provider:s}
     * const mgv = await require('mangrove.js').connect('http://127.0.0.1:8545'); // HTTP provider
     *
     * Options:
     * * privateKey: `0x...`
     * * mnemonic: `horse battery ...`
     * * path: `m/44'/60'/0'/...`
     * * provider: url, provider object, or chain string
     *
     * @returns {Mangrove} Returns an instance mangrove.js
     */
    static connect(options?: eth.CreateSignerOptions | string): Promise<Mangrove>;
    disconnect(): void;
    constructor(params: {
        signer: Signer;
        network: eth.ProviderNetwork;
        readOnly: boolean;
    });
    /************** */
    market(params: {
        base: string;
        quote: string;
        bookOptions?: Market.BookOptions;
    }): Promise<Market>;
    /** Get an OfferLogic object allowing one to monitor and set up an onchain offer logic*/
    offerLogic(logic: string): OfferLogic;
    /** Get a LiquidityProvider object to enable Mangrove's signer to pass buy and sell orders*/
    liquidityProvider(p: Market | {
        base: string;
        quote: string;
        bookOptions?: Market.BookOptions;
    }): Promise<LiquidityProvider>;
    token(name: string, options?: MgvToken.ConstructorOptions): MgvToken;
    /**
     * Read a contract address on the current network.
     *
     * Note that this reads from the static `Mangrove` address registry which is shared across instances of this class.
     */
    getAddress(name: string): string;
    /**
     * Set a contract address on the current network.
     *
     * Note that this writes to the static `Mangrove` address registry which is shared across instances of this class.
     */
    setAddress(name: string, address: string): void;
    /** Convert public token amount to internal token representation.
     *
     * if `nameOrDecimals` is a string, it is interpreted as a token name. Otherwise
     * it is the number of decimals.
     *
     * For convenience, has a static and an instance version.
     *
     *  @example
     *  ```
     *  Mangrove.toUnits(10,"USDC") // 10e6 as ethers.BigNumber
     *  mgv.toUnits(10,6) // 10e6 as ethers.BigNumber
     *  ```
     */
    static toUnits(amount: Bigish, nameOrDecimals: string | number): ethers.BigNumber;
    toUnits(amount: Bigish, nameOrDecimals: string | number): ethers.BigNumber;
    /** Convert internal token amount to public token representation.
     *
     * if `nameOrDecimals` is a string, it is interpreted as a token name. Otherwise
     * it is the number of decimals.
     *
     *  @example
     *  ```
     *  mgv.fromUnits("1e19","DAI") // 10
     *  mgv.fromUnits("1e19",18) // 10
     *  ```
     */
    fromUnits(amount: number | string | ethers.BigNumber, nameOrDecimals: string | number): Big;
    /** Provision available at mangrove for address given in argument, in ethers */
    balanceOf(address: string, overrides?: ethers.Overrides): Promise<Big>;
    fundMangrove(amount: Bigish, maker: string, overrides?: ethers.Overrides): Promise<ethers.ContractTransaction>;
    withdraw(amount: Bigish, overrides?: ethers.Overrides): Promise<ethers.ContractTransaction>;
    approveMangrove(tokenName: string, arg?: ApproveArgs): Promise<ethers.ContractTransaction>;
    /**
     * Return global Mangrove config
     */
    config(): Promise<Mangrove.GlobalConfig>;
    /********** */
    /**
     * Read all contract addresses on the given network.
     */
    static getAllAddresses(network: string): [string, string][];
    /**
     * Read a contract address on a given network.
     */
    static getAddress(name: string, network: string): string;
    /**
     * Set a contract address on the given network.
     */
    static setAddress(name: string, address: string, network: string): void;
    /**
     * Read decimals for `tokenName` on given network.
     * To read decimals directly onchain, use `fetchDecimals`.
     */
    static getDecimals(tokenName: string): number;
    /**
     * Read displayed decimals for `tokenName`.
     */
    static getDisplayedDecimals(tokenName: string): number;
    /**
     * Read displayed decimals for `tokenName` when displayed as a price.
     */
    static getDisplayedPriceDecimals(tokenName: string): number;
    /**
     * Set decimals for `tokenName` on current network.
     */
    static setDecimals(tokenName: string, dec: number): void;
    /**
     * Set displayed decimals for `tokenName`.
     */
    static setDisplayedDecimals(tokenName: string, dec: number): void;
    /**
     * Set displayed decimals for `tokenName` when displayed as a price.
     */
    static setDisplayedPriceDecimals(tokenName: string, dec: number): void;
    /**
     * Read chain for decimals of `tokenName` on current network and save them
     */
    static fetchDecimals(tokenName: string, provider: Provider): Promise<number>;
    /**
     * Setup dev node necessary contracts if needed, register dev Multicall2
     * address, listen to future additions (a script external to mangrove.js may
     * deploy contracts during execution).
     */
    static initAndListenToDevNode(devNode: DevNode): Promise<void>;
    /**
     * Returns open markets data according to mangrove reader.
     * @param from: start at market `from`. Default 0.
     * @param maxLen: max number of markets returned. Default all.
     * @param configs: fetch market's config information. Default true.
     * @param tokenInfo: fetch token information (symbol, decimals)
     * @note If an open market has a token with no/bad decimals/symbol function, this function will revert.
     */
    openMarketsData(params?: {
        from?: number;
        maxLen?: number | ethers.BigNumber;
        configs?: boolean;
        tokenInfos?: boolean;
    }): Promise<Mangrove.OpenMarketInfo[]>;
    /**
     * Returns open markets according to mangrove reader. Will internally update Mangrove token information.
     *
     * @param from: start at market `from` (default: 0)
     * @param maxLen: max number of markets returned (default: all)
     * @param noInit: do not initialize markets (default: false)
     * @param bookOptions: bookOptions argument to pass to every new market (default: undefined)
     */
    openMarkets(params?: {
        from?: number;
        maxLen?: number;
        noInit?: boolean;
        bookOptions?: Market.BookOptions;
    }): Promise<Market[]>;
    setCashness(symbol: string, cashness: number): void;
    static toBaseQuoteByCashness(symbol0: string, symbol1: string): {
        baseSymbol: string;
        quoteSymbol: string;
    };
}
export default Mangrove;
//# sourceMappingURL=mangrove.d.ts.map
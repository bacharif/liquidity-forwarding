import * as ethers from "ethers";
import { BigNumber } from "ethers";
import Mangrove from "./mangrove";
import MgvToken from "./mgvtoken";
import Semibook from "./semibook";
import { Bigish, typechain } from "./types";
import Trade from "./util/trade";
import Big from "big.js";
export declare const bookOptsDefault: Market.BookOptions;
import type { Awaited } from "ts-essentials";
import * as TCM from "./types/typechain/Mangrove";
import TradeEventManagement from "./util/tradeEventManagement";
import PrettyPrint, { prettyPrintFilter } from "./util/prettyPrint";
declare namespace Market {
    type BA = "bids" | "asks";
    type BS = "buy" | "sell";
    type MgvReader = typechain.MgvReader;
    type Failure = {
        offerId: number;
        reason: string;
        FailToDeliver?: Big;
        volumeGiven?: Big;
    };
    type Success = {
        offerId: number;
        got: Big;
        gave: Big;
    };
    type Summary = {
        got: Big;
        gave: Big;
        partialFill: boolean;
        bounty: Big;
        feePaid: Big;
    };
    type OrderResult = {
        txReceipt: ethers.ContractReceipt;
        summary: Summary;
        successes: Success[];
        tradeFailures: Failure[];
        posthookFailures: Failure[];
        offerWrites: {
            ba: Market.BA;
            offer: Market.OfferSlim;
        }[];
        restingOrder?: Market.OfferSlim;
    };
    type BookSubscriptionEvent = ({
        name: "OfferWrite";
    } & TCM.OfferWriteEvent) | ({
        name: "OfferFail";
    } & TCM.OfferFailEvent) | ({
        name: "OfferSuccess";
    } & TCM.OfferSuccessEvent) | ({
        name: "OfferRetract";
    } & TCM.OfferRetractEvent) | ({
        name: "SetGasbase";
    } & TCM.SetGasbaseEvent);
    type OrderRoute = "Mangrove" | "MangroveOrder";
    type TradeParams = {
        forceRoutingToMangroveOrder?: boolean;
        slippage?: number;
        fillOrKill?: boolean;
        expiryDate?: number;
    } & ({
        restingOrder?: RestingOrderParams;
    } | {
        offerId?: number;
    }) & ({
        volume: Bigish;
        price: Bigish;
    } | {
        total: Bigish;
        price: Bigish;
    } | {
        wants: Bigish;
        gives: Bigish;
        fillWants?: boolean;
    });
    type RestingOrderParams = {
        provision: Bigish;
    };
    type SnipeParams = {
        targets: {
            offerId: number;
            takerWants: Bigish;
            takerGives: Bigish;
            gasLimit?: number;
        }[];
        ba: Market.BA;
        fillWants?: boolean;
        requireOffersToFail?: boolean;
    };
    type RawSnipeParams = {
        ba: Market.BA;
        outboundTkn: string;
        inboundTkn: string;
        targets: [
            Promise<ethers.ethers.BigNumberish> | ethers.ethers.BigNumberish,
            Promise<ethers.ethers.BigNumberish> | ethers.ethers.BigNumberish,
            Promise<ethers.ethers.BigNumberish> | ethers.ethers.BigNumberish,
            Promise<ethers.ethers.BigNumberish> | ethers.ethers.BigNumberish
        ][];
        fillWants: boolean;
    };
    /**
     * Specification of how much volume to (potentially) trade on the market.
     *
     * `{given:100, what:"base", to:"buy"}` means buying 100 base tokens.
     *
     * `{given:10, what:"quote", to:"sell"})` means selling 10 quote tokens.
     */
    type VolumeParams = Semibook.VolumeParams & {
        /** Whether `given` is the market's base or quote. */
        what: "base" | "quote";
    };
    type DirectionlessVolumeParams = Omit<VolumeParams, "to">;
    type OptionalParams = {
        bookOptions: Market.BookOptions;
        noInit: boolean;
    };
    /**
     * Options that control how the book cache behaves.
     */
    type BookOptions = {
        /** The maximum number of offers to store in the cache.
         *
         * `maxOffers` and `desiredPrice` are mutually exclusive.
         */
        maxOffers?: number;
        /** The number of offers to fetch in one call.
         *
         * Defaults to `maxOffers` if it is set and positive; Otherwise `Semibook.DEFAULT_MAX_OFFERS` is used. */
        chunkSize?: number;
        /** The price that is expected to be used in calls to the market.
         * The cache will initially contain all offers with this price or better.
         * This can be useful in order to ensure a good pivot is readily available.
         *
         * `maxOffers` and `desiredPrice` are mutually exclusive.
         */
        desiredPrice?: Bigish;
        /**
         * The volume that is expected to be used in trades on the market.
         */
        desiredVolume?: VolumeParams;
    };
    type OfferSlim = {
        id: number;
        prev: number | undefined;
        gasprice: number;
        maker: string;
        gasreq: number;
        wants: Big;
        gives: Big;
        volume: Big;
        price: Big;
    };
    type Offer = OfferSlim & {
        next: number | undefined;
        offer_gasbase: number;
    };
    namespace BookReturns {
        type _BookReturns = Awaited<ReturnType<Market.MgvReader["functions"]["offerList"]>>;
        export type Indices = _BookReturns[1];
        export type Offers = _BookReturns[2];
        export type Details = _BookReturns[3];
        export {};
    }
    type BookSubscriptionCbArgument = {
        ba: Market.BA;
        offerId?: number;
        offer?: Offer;
    } & ({
        type: "OfferWrite";
    } | {
        type: "OfferFail";
        taker: string;
        takerWants: Big;
        takerGives: Big;
        mgvData: string;
    } | {
        type: "OfferSuccess";
        taker: string;
        takerWants: Big;
        takerGives: Big;
    } | {
        type: "OfferRetract";
    } | {
        type: "SetGasbase";
    });
    type MarketCallback<T> = (cbArg: BookSubscriptionCbArgument, event?: BookSubscriptionEvent, ethersLog?: ethers.providers.Log) => T;
    type StorableMarketCallback = MarketCallback<any>;
    type MarketFilter = MarketCallback<boolean | Promise<boolean>>;
    type SubscriptionParam = {
        type: "multiple";
    } | {
        type: "once";
        ok: (...a: any[]) => any;
        ko: (...a: any[]) => any;
        filter?: (...a: any[]) => boolean | Promise<boolean>;
    };
    type Book = {
        asks: Semibook;
        bids: Semibook;
    };
    type VolumeEstimate = {
        estimatedVolume: Big;
        givenResidue: Big;
    };
}
/**
 * The Market class focuses on a Mangrove market.
 * On-chain, markets are implemented as two offer lists,
 * one for asks (base,quote), the other for bids (quote,base).
 *
 * Market initialization needs to store the network name, so you cannot
 * directly use the constructor. Instead of `new Market(...)`, do
 *
 * `await Market.connect(...)`
 */
declare class Market {
    #private;
    mgv: Mangrove;
    base: MgvToken;
    quote: MgvToken;
    trade: Trade;
    tradeEventManagement: TradeEventManagement;
    prettyP: PrettyPrint;
    static connect(params: {
        mgv: Mangrove;
        base: string;
        quote: string;
    } & Partial<Market.OptionalParams>): Promise<Market>;
    disconnect(): void;
    /**
     * Initialize a new `params.base`:`params.quote` market.
     *
     * `params.mgv` will be used as mangrove instance
     */
    private constructor();
    initialize(): Promise<void>;
    /**
     * Return the semibooks of this market.
     *
     * Asks are standing offers to sell base and buy quote.
     * Bids are standing offers to buy base and sell quote.
     * All prices are in quote/base, all volumes are in base.
     * Order is from best to worse from taker perspective.
     */
    getBook(): Market.Book;
    /**
     * Return the asks or bids semibook
     */
    getSemibook(ba: Market.BA): Semibook;
    requestBook(opts?: Market.BookOptions): Promise<{
        asks: Market.Offer[];
        bids: Market.Offer[];
    }>;
    isActive(): Promise<boolean>;
    isLive(ba: Market.BA, offerId: number): Promise<boolean>;
    /** Given a price, find the id of the immediately-better offer in the
     * book. If there is no offer with a better price, `undefined` is returned.
     */
    getPivotId(ba: Market.BA, price: Bigish): Promise<number | undefined>;
    getOfferProvision(ba: Market.BA, gasreq: number, gasprice: number): Promise<Big>;
    getBidProvision(gasreq: number, gasprice: number): Promise<Big>;
    getAskProvision(gasreq: number, gasprice: number): Promise<Big>;
    bidInfo(offerId: number): Promise<Market.Offer>;
    askInfo(offerId: number): Promise<Market.Offer>;
    /** Returns struct containing offer details in the current market */
    offerInfo(ba: Market.BA, offerId: number): Promise<Market.Offer>;
    /**
     * Market buy order. Will attempt to buy base token using quote tokens.
     * Params can be of the form:
     * - `{volume,price}`: buy `volume` base tokens for a max average price of `price`.
     * - `{total,price}` : buy as many base tokens as possible using up to `total` quote tokens, with a max average price of `price`.
     * - `{wants,gives,fillWants?}`: accept implicit max average price of `gives/wants`
     *
     * In addition, `slippage` defines an allowed slippage in % of the amount of quote token, and
     * `restingOrder` or `offerId` can be supplied to create a resting order or to snipe a specific order, e.g.,
     * to account for gas.
     *
     * Will stop if
     * - book is empty, or
     * - price no longer good, or
     * - `wants` tokens have been bought.
     *
     * @example
     * ```
     * const market = await mgv.market({base:"USDC",quote:"DAI"};
     * market.buy({volume: 100, price: '1.01'}) //use strings to be exact
     * ```
     */
    buy(params: Market.TradeParams, overrides?: ethers.Overrides): Promise<{
        result: Promise<Market.OrderResult>;
        response: Promise<ethers.ContractTransaction>;
    }>;
    /**
     * Market sell order. Will attempt to sell base token for quote tokens.
     * Params can be of the form:
     * - `{volume,price}`: sell `volume` base tokens for a min average price of `price`.
     * - `{total,price}` : sell as many base tokens as possible buying up to `total` quote tokens, with a min average price of `price`.
     * - `{wants,gives,fillWants?}`: accept implicit min average price of `gives/wants`. `fillWants` will be false by default.
     *
     * In addition, `slippage` defines an allowed slippage in % of the amount of quote token, and
     * `restingOrder` or `offerId` can be supplied to create a resting order or to snipe a specific order, e.g.,
     * to account for gas.
     *
     * Will stop if
     * - book is empty, or
     * - price no longer good, or
     * -`gives` tokens have been sold.
     *
     * @example
     * ```
     * const market = await mgv.market({base:"USDC",quote:"DAI"})
     * market.sell({volume: 100, price: 1})
     * ```
     */
    sell(params: Market.TradeParams, overrides?: ethers.Overrides): Promise<{
        result: Promise<Market.OrderResult>;
        response: Promise<ethers.ContractTransaction>;
    }>;
    /**
     * Snipe specific offers.
     * Params are:
     * `targets`: an array of
     *    `offerId`: the offer to snipe
     *    `takerWants`: the amount of base token (for asks) or quote token (for bids) the taker wants
     *    `takerGives`: the amount of quote token (for asks) or base token (for bids) the take gives
     *    `gasLimit?`: the maximum gas requirement the taker will tolerate for that offer
     * `ba`: whether to snipe `asks` or `bids`
     * `fillWants?`: specifies whether you will buy at most `takerWants` (true), or you will buy as many tokens as possible as long as you don't spend more than `takerGives` (false).
     * `requireOffersToFail`: if true, then a successful offer will cause the call to fail without sniping anything.
     *     Note: Setting `requireOffersToFail=true` uses the cleaner contract and the taker needs to approve spending, with
     *     `await mgv.contract.approve(market.base.address, market.quote.address, mgv.cleanerContract.address, amount);`
     */
    snipe(params: Market.SnipeParams, overrides?: ethers.Overrides): Promise<{
        result: Promise<Market.OrderResult>;
        response: Promise<ethers.ContractTransaction>;
    }>;
    /**
     * Gets parameters to send to functions `market.mgv.cleanerContract.collect` or `market.mgv.contract.snipes`.
     * Params are:
     * `targets`: an array of
     *    `offerId`: the offer to snipe
     *    `takerWants`: the amount of base token (for asks) or quote token (for bids) the taker wants
     *    `takerGives`: the amount of quote token (for asks) or base token (for bids) the take gives
     *    `gasLimit?`: the maximum gas requirement the taker will tolerate for that offer
     * `ba`: whether to snipe `asks` or `bids`
     * `fillWants?`: specifies whether you will buy at most `takerWants` (true), or you will buy as many tokens as possible as long as you don't spend more than `takerGives` (false).
     * `requireOffersToFail`: defines whether a successful offer will cause the call to fail without sniping anything.
     */
    getRawSnipeParams(params: Market.SnipeParams, overrides?: ethers.Overrides): Promise<Market.RawSnipeParams>;
    estimateGas(bs: Market.BS, volume: BigNumber): Promise<BigNumber>;
    /**
     * Volume estimator.
     *
     * if you say `estimateVolume({given:100,what:"base",to:"buy"})`,
     *
     * it will give you an estimate of how much quote token you would have to
     * spend to get 100 base tokens.
     *
     * if you say `estimateVolume({given:10,what:"quote",to:"sell"})`,
     *
     * it will given you an estimate of how much base tokens you'd have to buy in
     * order to spend 10 quote tokens.
     * */
    estimateVolume(params: Market.VolumeParams): Promise<Market.VolumeEstimate>;
    estimateVolumeToReceive(params: Market.DirectionlessVolumeParams): Promise<Market.VolumeEstimate>;
    estimateVolumeToSpend(params: Market.DirectionlessVolumeParams): Promise<Market.VolumeEstimate>;
    /**
     * Return config local to a market.
     * Returned object is of the form
     * {bids,asks} where bids and asks are of type `localConfig`
     * Notes:
     * Amounts are converted to plain numbers.
     * density is converted to public token units per gas used
     * fee *remains* in basis points of the token being bought
     */
    config(): Promise<{
        asks: Mangrove.LocalConfig;
        bids: Mangrove.LocalConfig;
    }>;
    /** Pretty prints the current state of the asks of the market */
    consoleAsks(filter?: prettyPrintFilter): void;
    /** Pretty prints the current state of the bids of the market */
    consoleBids(filter?: prettyPrintFilter): void;
    /** Pretty prints the current state of the asks or bids of the market */
    prettyPrint(ba: Market.BA, filter: prettyPrintFilter): void;
    /**
     * Subscribe to order book updates.
     *
     * `cb` gets called whenever the order book is updated.
     *  Its first argument `event` is a summary of the event. It has the following properties:
     *
     * * `type` the type of change. May be: * `"OfferWrite"`: an offer was
     * inserted  or moved in the book.  * `"OfferFail"`, `"OfferSuccess"`,
     * `"OfferRetract"`: an offer was removed from the book because it failed,
     * succeeded, or was canceled.
     *
     * * `ba` is either `"bids"` or `"asks"`. The offer concerned by the change is
     * either an ask (an offer for `base` asking for `quote`) or a bid (`an offer
     * for `quote` asking for `base`).
     *
     * * `offer` is information about the offer, see type `Offer`.
     *
     * * `taker`, `takerWants`, `takerGives` (for `"OfferFail"` and
     * `"OfferSuccess"` only): address of the taker who executed the offer as well
     * as the volumes that were requested by the taker.
     *
     * * `mgvData` : extra data from mangrove and the maker
     * contract. See the [Mangrove contracts documentation](#TODO) for the list of possible status codes.
     *
     * `opts` may specify the maximum of offers to read initially, and the chunk
     * size used when querying the reader contract (always ran locally).
     *
     * @example
     * ```
     * const market = await mgv.market({base:"USDC",quote:"DAI"}
     * market.subscribe((event,utils) => console.log(event.type, utils.book()))
     * ```
     *
     * @note Only one subscription may be active at a time.
     */
    subscribe(cb: Market.MarketCallback<void>): void;
    /**
     *  Returns a promise which is fulfilled after execution of the callback.
     */
    once<T>(cb: Market.MarketCallback<T>, filter?: Market.MarketFilter): Promise<T>;
    unsubscribe(cb: Market.StorableMarketCallback): void;
    /** Determine which token will be Mangrove's outbound/inbound depending on whether you're working with bids or asks. */
    getOutboundInbound(ba: Market.BA): {
        outbound_tkn: MgvToken;
        inbound_tkn: MgvToken;
    };
    /** Determine which token will be Mangrove's outbound/inbound depending on whether you're working with bids or asks. */
    static getOutboundInbound(ba: Market.BA, base: MgvToken, quote: MgvToken): {
        outbound_tkn: MgvToken;
        inbound_tkn: MgvToken;
    };
    /** Determine whether gives or wants will be baseVolume/quoteVolume depending on whether you're working with bids or asks. */
    static getBaseQuoteVolumes(ba: Market.BA, gives: Big, wants: Big): {
        baseVolume: Big;
        quoteVolume: Big;
    };
    /** Determine the price from gives or wants depending on whether you're working with bids or asks. */
    static getPrice(ba: Market.BA, gives: Big, wants: Big): Big;
    /** Determine the wants from gives and price depending on whether you're working with bids or asks. */
    static getWantsForPrice(ba: Market.BA, gives: Big, price: Big): Big;
    /** Determine the gives from wants and price depending on whether you're working with bids or asks. */
    static getGivesForPrice(ba: Market.BA, wants: Big, price: Big): Big;
    /** Determine gives and wants from a volume (in base) and a price depending on whether you're working with bids or asks. */
    static getGivesWantsForVolumeAtPrice(ba: Market.BA, volume: Big, price: Big): {
        gives: Big;
        wants: Big;
    };
    /** Determine the first decimal place where the smallest price difference between neighboring offers in the order book cache is visible. */
    getDisplayDecimalsForPriceDifferences(): number;
    /** Determine the first decimal place where the smallest price difference between neighboring offers is visible. */
    static getDisplayDecimalsForPriceDifferences(offers: Market.Offer[]): number;
}
export default Market;
//# sourceMappingURL=market.d.ts.map
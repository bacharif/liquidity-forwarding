import { Big } from "big.js";
import { BigNumber, ethers } from "ethers";
import { Mangrove, Market } from ".";
import { Bigish } from "./types";
import Trade from "./util/trade";
declare namespace Semibook {
    type Event = {
        cbArg: Market.BookSubscriptionCbArgument;
        event: Market.BookSubscriptionEvent;
        ethersLog: ethers.providers.Log;
    };
    type EventListener = (e: Event) => void;
    type BlockListener = (n: number) => void;
    /**
     * Specification of how much volume to (potentially) trade on the semibook.
     *
     * `{given:100, to:"buy"}` means buying 100 base tokens.
     * `{given:100, to:"buy", boundary: 10})` means buying 100 quote tokens for a max. avg. price of 1/10 (boundary/given).
     *
     * `{given:10, to:"sell"})` means selling 10 quote tokens.
     * `{given:10, to:"sell", boundary: 5})` means selling 10 quote tokens for a min. avg. price of 0.5 (given/boundary).
     */
    type VolumeParams = {
        /** Amount of token to trade. */
        given: Bigish;
        /** Whether `given` is base to be bought or quote to be sold. */
        to: Market.BS;
        /** Optional: induce a max avg. price after which to stop buying/selling. */
        boundary?: Bigish;
    };
    /**
     * Options that control how the book cache behaves.
     *
     * `maxOffers` and `desiredPrice` are mutually exclusive.
     * If none of these are specfied, the default is `maxOffers` = `Semibook.DEFAULT_MAX_OFFERS`.
     */
    type Options = {
        /** The maximum number of offers to store in the cache.
         *
         * `maxOffers` and `desiredPrice` are mutually exclusive.
         */
        maxOffers?: number;
        /** The number of offers to fetch in one call.
         *
         * Defaults to `maxOffers` if it is set and positive; Otherwise `Semibook.DEFAULT_MAX_OFFERS` is used. */
        chunkSize?: number;
        /** The price that is expected to be used in calls to the market.
         * The cache will initially contain all offers with this price or better.
         * This can be useful in order to ensure a good pivot is readily available.
         */
        desiredPrice?: Bigish;
        /**
         * The volume that is expected to be used in trades on the market.
         */
        desiredVolume?: VolumeParams;
    };
    /**
     * An iterator over a semibook cache.
     */
    interface CacheIterator extends IterableIterator<Market.Offer> {
        /** Filter the offers in the cache using a predicate.
         *
         * @param predicate Function is a predicate, to test each element of the array.
         *   Should return `true` if the element should be kept; otherwise `false` should be returned.
         */
        filter(predicate: (offer: Market.Offer) => boolean): CacheIterator;
        /** Returns the value of the first element in the provided array that
         * satisfies the provided predicate. If no values satisfy the testing function,
         * `undefined` is returned.
         *
         * @param predicate Function is a predicate, to test each element of the array.
         *  The firs offer that satisifies the predicate is returned;
         *  otherwise `undefined` is returned.
         */
        find(predicate: (offer: Market.Offer) => boolean): Market.Offer;
        /** Returns the elements in an array. */
        toArray(): Market.Offer[];
    }
}
/**
 * The Semibook is a data structure for maintaining a cached prefix
 * of an offer list for one side (asks or bids) of a market.
 *
 * While offer lists on-chain for a market A-B are symmetric (the offer lists are
 * the same for the market B-A), a `Semibook` depends on the market:
 *
 * - Prices are in terms of quote tokens
 * - Volumes are in terms of base tokens
 */
declare class Semibook implements Iterable<Market.Offer> {
    #private;
    static readonly DEFAULT_MAX_OFFERS = 50;
    readonly ba: Market.BA;
    readonly market: Market;
    readonly options: Semibook.Options;
    tradeManagement: Trade;
    static connect(market: Market, ba: Market.BA, eventListener: Semibook.EventListener, options: Semibook.Options): Promise<Semibook>;
    /** Stop listening to events from mangrove */
    disconnect(): void;
    requestOfferListPrefix(options: Semibook.Options): Promise<Market.Offer[]>;
    /** Returns struct containing offer details in the current offer list */
    offerInfo(offerId: number): Promise<Market.Offer>;
    /**
     * Return config local to a semibook.
     * Notes:
     * Amounts are converted to plain numbers.
     * density is converted to public token units per gas used
     * fee *remains* in basis points of the token being bought
     */
    getConfig(blockNumber?: number): Promise<Mangrove.LocalConfig>;
    getRawConfig(blockNumber?: number): Promise<Mangrove.RawConfig>;
    /** Returns the number of offers in the cache. */
    size(): number;
    /** Returns the id of the best offer in the cache */
    getBestInCache(): number | undefined;
    /** Returns an iterator over the offers in the cache. */
    [Symbol.iterator](): Semibook.CacheIterator;
    /** Convenience method for getting an iterator without having to call `[Symbol.iterator]()`. */
    iter(): Semibook.CacheIterator;
    /** Given a price, find the id of the immediately-better offer in the
     * semibook. If there is no offer with a better price, `undefined` is returned.
     */
    getPivotId(price: Bigish): Promise<number | undefined>;
    /**
     * Volume estimator.
     *
     * if you say `estimateVolume({given:100,to:"buy"})`,
     *
     * it will give you an estimate of how much quote token you would have to
     * spend to get 100 base tokens.
     *
     * if you say `estimateVolume({given:10,to:"sell"})`,
     *
     * it will given you an estimate of how much base tokens you'd have to buy in
     * order to spend 10 quote tokens.
     *
     * if you add a `boundary` field, it either means
     * - the minimum amount you want to receive if you spend all `given` (if to:"sell"), or
     * - the maximum amount you are ready to spend if you buy all `given` (if to:"buy")
     *
     * So for instance, if you say {given:10,to:"sell",boundary:"5"}, estimateVolume will return the volume you will be able to receive if selling up to 10 at a min price of 10/5.
     *
     * The returned `givenResidue` is how much of the given token that cannot be
     * traded due to insufficient volume on the book / price becoming bad.
     */
    estimateVolume(params: Semibook.VolumeParams): Promise<Market.VolumeEstimate>;
    simulateMarketOrder(initialWants: Big, initialGives: Big, fillWants: boolean): Promise<{
        wants: Big;
        gives: Big;
        totalGot: Big;
        totalGave: Big;
    }>;
    /** Returns `true` if `price` is better than `referencePrice`; Otherwise, `false` is returned.
     */
    isPriceBetter(price: Bigish, referencePrice: Bigish): boolean;
    /** Returns `true` if `price` is worse than `referencePrice`; Otherwise, `false` is returned.
     */
    isPriceWorse(price: Bigish, referencePrice: Bigish): boolean;
    getMaxGasReq(): Promise<number | undefined>;
    private constructor();
    static rawLocalConfigToLocalConfig(local: Mangrove.RawConfig["local"], outboundDecimals: number): Mangrove.LocalConfig;
    static rawIdToId(rawId: BigNumber): number | undefined;
    static getIsVolumeDesiredForAsks(opts: Market.BookOptions): boolean;
    static getIsVolumeDesiredForBids(opts: Market.BookOptions): boolean;
}
export default Semibook;
//# sourceMappingURL=semibook.d.ts.map
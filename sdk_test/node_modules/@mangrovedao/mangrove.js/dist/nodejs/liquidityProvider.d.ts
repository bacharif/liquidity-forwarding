import * as ethers from "ethers";
import Market from "./market";
import { Bigish } from "./types";
import Mangrove from "./mangrove";
import Big from "big.js";
import { OfferLogic } from ".";
import PrettyPrint, { prettyPrintFilter } from "./util/prettyPrint";
import { ApproveArgs } from "./mgvtoken";
declare namespace LiquidityProvider {
    export type ConstructionParams = {
        mgv: Mangrove;
        logic?: OfferLogic;
        eoa?: string;
        market: Market;
    };
    /** Connect to MangroveOffer.
     *  This basic maker contract will relay new/cancel/update
     *  offer order.
     */
    type OptParams = {
        fund?: Bigish;
    };
    export type OfferParams = ({
        price: Bigish;
        volume: Bigish;
    } & OptParams) | ({
        wants: Bigish;
        gives: Bigish;
    } & OptParams);
    export type OfferActionResult = {
        offerType: Market.BA;
        market: string;
        txReceipt: ethers.ContractReceipt;
        id: number;
        gasprice?: number;
        gasreq?: number;
        refund?: Big;
    };
    export {};
}
/**
 * The LiquidityProvider class connects an offerLogic (or an EOA) to a market.
 * It posts onchain offers.
 * */
declare class LiquidityProvider {
    #private;
    mgv: Mangrove;
    logic?: OfferLogic;
    eoa?: string;
    market: Market;
    prettyP: PrettyPrint;
    constructor(p: LiquidityProvider.ConstructionParams);
    computeOfferProvision(ba: Market.BA, opts?: {
        id?: number;
        gasreq?: number;
        gasprice?: number;
    }): Promise<Big>;
    computeBidProvision(opts?: {
        id?: number;
        gasreq?: number;
        gasprice?: number;
    }): Promise<Big>;
    computeAskProvision(opts?: {
        id?: number;
        gasreq?: number;
        gasprice?: number;
    }): Promise<Big>;
    /** Given a price, find the id of the immediately-better offer in the
     * semibook. If there is no offer with a better price, `undefined` is returned.
     */
    getBidPivotId(price: Bigish): Promise<number | undefined>;
    getAskPivotId(price: Bigish): Promise<number | undefined>;
    /** List all of the maker's asks in the cache */
    asks(): Market.Offer[];
    /** List all of the maker's bids in the cache */
    bids(): Market.Offer[];
    /** Pretty prints the current state of the asks for the maker */
    consoleAsks(filter?: prettyPrintFilter): void;
    /** Pretty prints the current state of the bids for the maker */
    consoleBids(filter?: prettyPrintFilter): void;
    /**
     *  Given offer params (bids/asks + price info as wants&gives or price&volume),
     *  return {price,wants,gives}
     */
    static normalizeOfferParams(p: {
        ba: Market.BA;
    } & LiquidityProvider.OfferParams): {
        price: Big;
        wants: Big;
        gives: Big;
        gasreq?: number;
        gasprice?: number;
        fund?: Bigish;
    };
    static optValueToPayableOverride(overrides: ethers.Overrides, fund?: Bigish): ethers.PayableOverrides;
    /** Post a new ask */
    newAsk(p: LiquidityProvider.OfferParams, overrides?: ethers.Overrides): Promise<{
        id: number;
        event: ethers.providers.Log;
    }>;
    /** Post a new bid */
    newBid(p: LiquidityProvider.OfferParams, overrides?: ethers.Overrides): Promise<{
        id: number;
        event: ethers.providers.Log;
    }>;
    newOffer(p: {
        ba: Market.BA;
    } & LiquidityProvider.OfferParams, overrides?: ethers.Overrides): Promise<{
        id: number;
        pivot: number;
        event: ethers.providers.Log;
    }>;
    /** Update an existing ask */
    /** e.g `updateAsk(42,{price:0.2, volume:1000, gasreq:100000, fund:0.01})`*/
    /** to change volume and price of the offer, and update its gas requirement and fund 0.01 ether to maker balance*/
    updateAsk(id: number, p: LiquidityProvider.OfferParams, overrides?: ethers.PayableOverrides): Promise<{
        event: ethers.providers.Log;
    }>;
    /** Update an existing offer */
    updateBid(id: number, p: LiquidityProvider.OfferParams, overrides?: ethers.PayableOverrides): Promise<{
        event: ethers.providers.Log;
    }>;
    updateOffer(id: number, p: {
        ba: Market.BA;
    } & LiquidityProvider.OfferParams, overrides?: ethers.PayableOverrides): Promise<{
        event: ethers.providers.Log;
    }>;
    /** Cancel an ask. If deprovision is true, will return the offer's provision to the maker balance at Mangrove. */
    retractAsk(id: number, deprovision?: boolean, overrides?: ethers.Overrides): Promise<void>;
    /** Cancel a bid. If deprovision is true, will return the offer's provision to the maker balance at Mangrove. */
    retractBid(id: number, deprovision?: boolean, overrides?: ethers.Overrides): Promise<void>;
    retractOffer(ba: Market.BA, id: number, deprovision?: boolean, overrides?: ethers.Overrides): Promise<void>;
    approveAsks(arg?: ApproveArgs): Promise<ethers.ContractTransaction>;
    approveBids(arg?: ApproveArgs): Promise<ethers.ContractTransaction>;
    getMissingProvision(ba: Market.BA, opts?: {
        id?: number;
        gasreq?: number;
        gasprice?: number;
    }): Promise<Big>;
}
export default LiquidityProvider;
//# sourceMappingURL=liquidityProvider.d.ts.map
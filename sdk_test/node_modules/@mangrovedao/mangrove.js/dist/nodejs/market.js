"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Market_instances, _Market_subscriptions, _Market_asksSemibook, _Market_bidsSemibook, _Market_initClosure, _Market_initialize, _Market_semibookEventCallback;
Object.defineProperty(exports, "__esModule", { value: true });
exports.bookOptsDefault = void 0;
const ethers_1 = require("ethers"); // syntactic sugar
const semibook_1 = __importDefault(require("./semibook"));
const trade_1 = __importDefault(require("./util/trade"));
let canConstructMarket = false;
const MAX_MARKET_ORDER_GAS = 6500000;
exports.bookOptsDefault = {
    maxOffers: semibook_1.default.DEFAULT_MAX_OFFERS,
};
const tradeEventManagement_1 = __importDefault(require("./util/tradeEventManagement"));
const prettyPrint_1 = __importDefault(require("./util/prettyPrint"));
// no unsubscribe yet
/**
 * The Market class focuses on a Mangrove market.
 * On-chain, markets are implemented as two offer lists,
 * one for asks (base,quote), the other for bids (quote,base).
 *
 * Market initialization needs to store the network name, so you cannot
 * directly use the constructor. Instead of `new Market(...)`, do
 *
 * `await Market.connect(...)`
 */
class Market {
    /**
     * Initialize a new `params.base`:`params.quote` market.
     *
     * `params.mgv` will be used as mangrove instance
     */
    constructor(params) {
        _Market_instances.add(this);
        _Market_subscriptions.set(this, void 0);
        _Market_asksSemibook.set(this, void 0);
        _Market_bidsSemibook.set(this, void 0);
        _Market_initClosure.set(this, void 0);
        this.trade = new trade_1.default();
        this.tradeEventManagement = new tradeEventManagement_1.default();
        this.prettyP = new prettyPrint_1.default();
        if (!canConstructMarket) {
            throw Error("Mangrove Market must be initialized async with Market.connect (constructors cannot be async)");
        }
        __classPrivateFieldSet(this, _Market_subscriptions, new Map(), "f");
        this.mgv = params.mgv;
        this.base = this.mgv.token(params.base);
        this.quote = this.mgv.token(params.quote);
    }
    static async connect(params) {
        canConstructMarket = true;
        const market = new Market(params);
        canConstructMarket = false;
        if (params["noInit"]) {
            __classPrivateFieldSet(market, _Market_initClosure, () => {
                return __classPrivateFieldGet(market, _Market_instances, "m", _Market_initialize).call(market, params.bookOptions);
            }, "f");
        }
        else {
            await __classPrivateFieldGet(market, _Market_instances, "m", _Market_initialize).call(market, params.bookOptions);
        }
        return market;
    }
    /* Stop listening to events from mangrove */
    disconnect() {
        __classPrivateFieldGet(this, _Market_asksSemibook, "f").disconnect();
        __classPrivateFieldGet(this, _Market_bidsSemibook, "f").disconnect();
    }
    initialize() {
        if (typeof __classPrivateFieldGet(this, _Market_initClosure, "f") === "undefined") {
            throw new Error("Cannot initialize already initialized market.");
        }
        else {
            const initClosure = __classPrivateFieldGet(this, _Market_initClosure, "f");
            __classPrivateFieldSet(this, _Market_initClosure, undefined, "f");
            return initClosure();
        }
    }
    /**
     * Return the semibooks of this market.
     *
     * Asks are standing offers to sell base and buy quote.
     * Bids are standing offers to buy base and sell quote.
     * All prices are in quote/base, all volumes are in base.
     * Order is from best to worse from taker perspective.
     */
    getBook() {
        return {
            asks: __classPrivateFieldGet(this, _Market_asksSemibook, "f"),
            bids: __classPrivateFieldGet(this, _Market_bidsSemibook, "f"),
        };
    }
    /**
     * Return the asks or bids semibook
     */
    getSemibook(ba) {
        return ba === "asks" ? __classPrivateFieldGet(this, _Market_asksSemibook, "f") : __classPrivateFieldGet(this, _Market_bidsSemibook, "f");
    }
    async requestBook(opts = exports.bookOptsDefault) {
        const asksPromise = __classPrivateFieldGet(this, _Market_asksSemibook, "f").requestOfferListPrefix(opts);
        const bidsPromise = __classPrivateFieldGet(this, _Market_bidsSemibook, "f").requestOfferListPrefix(opts);
        return {
            asks: await asksPromise,
            bids: await bidsPromise,
        };
    }
    async isActive() {
        const config = await this.config();
        return config.asks.active && config.bids.active;
    }
    async isLive(ba, offerId) {
        const offer = await this.getSemibook(ba).offerInfo(offerId);
        return offer.gives.gt(0);
    }
    /** Given a price, find the id of the immediately-better offer in the
     * book. If there is no offer with a better price, `undefined` is returned.
     */
    async getPivotId(ba, price) {
        return this.getSemibook(ba).getPivotId(price);
    }
    async getOfferProvision(ba, gasreq, gasprice) {
        const { outbound_tkn, inbound_tkn } = this.getOutboundInbound(ba);
        const prov = await this.mgv.readerContract["getProvision(address,address,uint256,uint256)"](outbound_tkn.address, inbound_tkn.address, gasreq, gasprice);
        return this.mgv.fromUnits(prov, 18);
    }
    getBidProvision(gasreq, gasprice) {
        return this.getOfferProvision("bids", gasreq, gasprice);
    }
    getAskProvision(gasreq, gasprice) {
        return this.getOfferProvision("asks", gasreq, gasprice);
    }
    bidInfo(offerId) {
        return this.offerInfo("bids", offerId);
    }
    askInfo(offerId) {
        return this.offerInfo("asks", offerId);
    }
    /** Returns struct containing offer details in the current market */
    async offerInfo(ba, offerId) {
        return this.getSemibook(ba).offerInfo(offerId);
    }
    /**
     * Market buy order. Will attempt to buy base token using quote tokens.
     * Params can be of the form:
     * - `{volume,price}`: buy `volume` base tokens for a max average price of `price`.
     * - `{total,price}` : buy as many base tokens as possible using up to `total` quote tokens, with a max average price of `price`.
     * - `{wants,gives,fillWants?}`: accept implicit max average price of `gives/wants`
     *
     * In addition, `slippage` defines an allowed slippage in % of the amount of quote token, and
     * `restingOrder` or `offerId` can be supplied to create a resting order or to snipe a specific order, e.g.,
     * to account for gas.
     *
     * Will stop if
     * - book is empty, or
     * - price no longer good, or
     * - `wants` tokens have been bought.
     *
     * @example
     * ```
     * const market = await mgv.market({base:"USDC",quote:"DAI"};
     * market.buy({volume: 100, price: '1.01'}) //use strings to be exact
     * ```
     */
    buy(params, overrides = {}) {
        return this.trade.order("buy", params, this, overrides);
    }
    /**
     * Market sell order. Will attempt to sell base token for quote tokens.
     * Params can be of the form:
     * - `{volume,price}`: sell `volume` base tokens for a min average price of `price`.
     * - `{total,price}` : sell as many base tokens as possible buying up to `total` quote tokens, with a min average price of `price`.
     * - `{wants,gives,fillWants?}`: accept implicit min average price of `gives/wants`. `fillWants` will be false by default.
     *
     * In addition, `slippage` defines an allowed slippage in % of the amount of quote token, and
     * `restingOrder` or `offerId` can be supplied to create a resting order or to snipe a specific order, e.g.,
     * to account for gas.
     *
     * Will stop if
     * - book is empty, or
     * - price no longer good, or
     * -`gives` tokens have been sold.
     *
     * @example
     * ```
     * const market = await mgv.market({base:"USDC",quote:"DAI"})
     * market.sell({volume: 100, price: 1})
     * ```
     */
    sell(params, overrides = {}) {
        return this.trade.order("sell", params, this, overrides);
    }
    /**
     * Snipe specific offers.
     * Params are:
     * `targets`: an array of
     *    `offerId`: the offer to snipe
     *    `takerWants`: the amount of base token (for asks) or quote token (for bids) the taker wants
     *    `takerGives`: the amount of quote token (for asks) or base token (for bids) the take gives
     *    `gasLimit?`: the maximum gas requirement the taker will tolerate for that offer
     * `ba`: whether to snipe `asks` or `bids`
     * `fillWants?`: specifies whether you will buy at most `takerWants` (true), or you will buy as many tokens as possible as long as you don't spend more than `takerGives` (false).
     * `requireOffersToFail`: if true, then a successful offer will cause the call to fail without sniping anything.
     *     Note: Setting `requireOffersToFail=true` uses the cleaner contract and the taker needs to approve spending, with
     *     `await mgv.contract.approve(market.base.address, market.quote.address, mgv.cleanerContract.address, amount);`
     */
    snipe(params, overrides = {}) {
        return this.trade.snipe(params, this, overrides);
    }
    /**
     * Gets parameters to send to functions `market.mgv.cleanerContract.collect` or `market.mgv.contract.snipes`.
     * Params are:
     * `targets`: an array of
     *    `offerId`: the offer to snipe
     *    `takerWants`: the amount of base token (for asks) or quote token (for bids) the taker wants
     *    `takerGives`: the amount of quote token (for asks) or base token (for bids) the take gives
     *    `gasLimit?`: the maximum gas requirement the taker will tolerate for that offer
     * `ba`: whether to snipe `asks` or `bids`
     * `fillWants?`: specifies whether you will buy at most `takerWants` (true), or you will buy as many tokens as possible as long as you don't spend more than `takerGives` (false).
     * `requireOffersToFail`: defines whether a successful offer will cause the call to fail without sniping anything.
     */
    getRawSnipeParams(params, overrides = {}) {
        return this.trade.getRawSnipeParams(params, this, overrides);
    }
    async estimateGas(bs, volume) {
        const semibook = bs === "buy" ? __classPrivateFieldGet(this, _Market_asksSemibook, "f") : __classPrivateFieldGet(this, _Market_bidsSemibook, "f");
        const { local: { density, offer_gasbase }, } = await semibook.getRawConfig();
        const maxGasreqOffer = (await semibook.getMaxGasReq()) ?? 0;
        const maxMarketOrderGas = ethers_1.BigNumber.from(MAX_MARKET_ORDER_GAS);
        const estimation = density.isZero()
            ? maxMarketOrderGas
            : offer_gasbase.add(volume.div(density)).add(maxGasreqOffer);
        if (estimation.lt(maxMarketOrderGas))
            return estimation;
        return maxMarketOrderGas;
    }
    /**
     * Volume estimator.
     *
     * if you say `estimateVolume({given:100,what:"base",to:"buy"})`,
     *
     * it will give you an estimate of how much quote token you would have to
     * spend to get 100 base tokens.
     *
     * if you say `estimateVolume({given:10,what:"quote",to:"sell"})`,
     *
     * it will given you an estimate of how much base tokens you'd have to buy in
     * order to spend 10 quote tokens.
     * */
    async estimateVolume(params) {
        if ((params.what === "base" && params.to === "buy") ||
            (params.what === "quote" && params.to === "sell")) {
            return await __classPrivateFieldGet(this, _Market_asksSemibook, "f").estimateVolume(params);
        }
        else {
            return await __classPrivateFieldGet(this, _Market_bidsSemibook, "f").estimateVolume(params);
        }
    }
    /* Convenience method: estimate volume to be received given an amount of base/quote you are ready to spend. */
    async estimateVolumeToReceive(params) {
        return this.estimateVolume({ ...params, to: "sell" });
    }
    /* Convenience method: estimate volume to be spent given an amount of base/quote you want to receive. */
    async estimateVolumeToSpend(params) {
        return this.estimateVolume({ ...params, to: "buy" });
    }
    /* Convenience method to estimate volume */
    /**
     * Return config local to a market.
     * Returned object is of the form
     * {bids,asks} where bids and asks are of type `localConfig`
     * Notes:
     * Amounts are converted to plain numbers.
     * density is converted to public token units per gas used
     * fee *remains* in basis points of the token being bought
     */
    async config() {
        const asksConfigPromise = __classPrivateFieldGet(this, _Market_asksSemibook, "f").getConfig();
        const bidsConfigPromise = __classPrivateFieldGet(this, _Market_bidsSemibook, "f").getConfig();
        return {
            asks: await asksConfigPromise,
            bids: await bidsConfigPromise,
        };
    }
    /** Pretty prints the current state of the asks of the market */
    consoleAsks(filter) {
        this.prettyP.consoleOffers(this.getSemibook("asks"), filter);
    }
    /** Pretty prints the current state of the bids of the market */
    consoleBids(filter) {
        this.prettyP.consoleOffers(this.getSemibook("bids"), filter);
    }
    /** Pretty prints the current state of the asks or bids of the market */
    prettyPrint(ba, filter) {
        const offers = this.getSemibook(ba);
        this.prettyP.prettyPrint(offers, filter);
    }
    /**
     * Subscribe to order book updates.
     *
     * `cb` gets called whenever the order book is updated.
     *  Its first argument `event` is a summary of the event. It has the following properties:
     *
     * * `type` the type of change. May be: * `"OfferWrite"`: an offer was
     * inserted  or moved in the book.  * `"OfferFail"`, `"OfferSuccess"`,
     * `"OfferRetract"`: an offer was removed from the book because it failed,
     * succeeded, or was canceled.
     *
     * * `ba` is either `"bids"` or `"asks"`. The offer concerned by the change is
     * either an ask (an offer for `base` asking for `quote`) or a bid (`an offer
     * for `quote` asking for `base`).
     *
     * * `offer` is information about the offer, see type `Offer`.
     *
     * * `taker`, `takerWants`, `takerGives` (for `"OfferFail"` and
     * `"OfferSuccess"` only): address of the taker who executed the offer as well
     * as the volumes that were requested by the taker.
     *
     * * `mgvData` : extra data from mangrove and the maker
     * contract. See the [Mangrove contracts documentation](#TODO) for the list of possible status codes.
     *
     * `opts` may specify the maximum of offers to read initially, and the chunk
     * size used when querying the reader contract (always ran locally).
     *
     * @example
     * ```
     * const market = await mgv.market({base:"USDC",quote:"DAI"}
     * market.subscribe((event,utils) => console.log(event.type, utils.book()))
     * ```
     *
     * @note Only one subscription may be active at a time.
     */
    subscribe(cb) {
        __classPrivateFieldGet(this, _Market_subscriptions, "f").set(cb, { type: "multiple" });
    }
    /**
     *  Returns a promise which is fulfilled after execution of the callback.
     */
    async once(cb, filter) {
        return new Promise((ok, ko) => {
            const params = { type: "once", ok, ko };
            if (typeof filter !== "undefined") {
                params.filter = filter;
            }
            __classPrivateFieldGet(this, _Market_subscriptions, "f").set(cb, params);
        });
    }
    /* Stop calling a user-provided function on book-related events. */
    unsubscribe(cb) {
        __classPrivateFieldGet(this, _Market_subscriptions, "f").delete(cb);
    }
    /** Determine which token will be Mangrove's outbound/inbound depending on whether you're working with bids or asks. */
    getOutboundInbound(ba) {
        return Market.getOutboundInbound(ba, this.base, this.quote);
    }
    /** Determine which token will be Mangrove's outbound/inbound depending on whether you're working with bids or asks. */
    static getOutboundInbound(ba, base, quote) {
        return {
            outbound_tkn: ba === "asks" ? base : quote,
            inbound_tkn: ba === "asks" ? quote : base,
        };
    }
    /** Determine whether gives or wants will be baseVolume/quoteVolume depending on whether you're working with bids or asks. */
    static getBaseQuoteVolumes(ba, gives, wants) {
        return {
            baseVolume: ba === "asks" ? gives : wants,
            quoteVolume: ba === "asks" ? wants : gives,
        };
    }
    /** Determine the price from gives or wants depending on whether you're working with bids or asks. */
    static getPrice(ba, gives, wants) {
        const { baseVolume, quoteVolume } = Market.getBaseQuoteVolumes(ba, gives, wants);
        return baseVolume.gt(0) ? quoteVolume.div(baseVolume) : undefined;
    }
    /** Determine the wants from gives and price depending on whether you're working with bids or asks. */
    static getWantsForPrice(ba, gives, price) {
        return ba === "asks" ? gives.mul(price) : gives.div(price);
    }
    /** Determine the gives from wants and price depending on whether you're working with bids or asks. */
    static getGivesForPrice(ba, wants, price) {
        return ba === "asks" ? wants.div(price) : wants.mul(price);
    }
    /** Determine gives and wants from a volume (in base) and a price depending on whether you're working with bids or asks. */
    static getGivesWantsForVolumeAtPrice(ba, volume, price) {
        const gives = ba === "asks" ? volume : volume.mul(price);
        const wants = ba === "asks" ? volume.mul(price) : volume;
        return {
            gives,
            wants,
        };
    }
    /** Determine the first decimal place where the smallest price difference between neighboring offers in the order book cache is visible. */
    getDisplayDecimalsForPriceDifferences() {
        return Market.getDisplayDecimalsForPriceDifferences([
            ...__classPrivateFieldGet(this, _Market_asksSemibook, "f"),
            ...[...__classPrivateFieldGet(this, _Market_bidsSemibook, "f")].slice().reverse(),
        ]);
    }
    /** Determine the first decimal place where the smallest price difference between neighboring offers is visible. */
    static getDisplayDecimalsForPriceDifferences(offers) {
        if (offers.length <= 1) {
            return 0;
        }
        const absPriceDiffs = new Array(offers.length - 1);
        offers.slice(1).reduce((prevPrice, o, i) => {
            absPriceDiffs[i] = prevPrice.sub(o.price).abs();
            return o.price;
        }, offers[0].price);
        const minBig = (b1, b2) => {
            if (b1 === undefined) {
                return b2;
            }
            else if (b2 === undefined) {
                return b1;
            }
            return b1.lt(b2) ? b1 : b2;
        };
        const minAbsPriceDiff = absPriceDiffs
            .filter((d) => !d.eq(0))
            .reduce(minBig, undefined);
        return minAbsPriceDiff === undefined
            ? 0
            : -Math.floor(Math.log10(minAbsPriceDiff.toNumber()));
    }
}
_Market_subscriptions = new WeakMap(), _Market_asksSemibook = new WeakMap(), _Market_bidsSemibook = new WeakMap(), _Market_initClosure = new WeakMap(), _Market_instances = new WeakSet(), _Market_initialize = async function _Market_initialize(opts = exports.bookOptsDefault) {
    const semibookDesiredVolume = opts.desiredVolume === undefined
        ? undefined
        : { given: opts.desiredVolume.given, to: opts.desiredVolume.to };
    const getSemibookOpts = (ba) => ({
        maxOffers: opts.maxOffers,
        chunkSize: opts.chunkSize,
        desiredPrice: opts.desiredPrice,
        desiredVolume: (ba === "asks" && semibook_1.default.getIsVolumeDesiredForAsks(opts)) ||
            (ba === "bids" && semibook_1.default.getIsVolumeDesiredForBids(opts))
            ? semibookDesiredVolume
            : undefined,
    });
    const asksPromise = semibook_1.default.connect(this, "asks", (e) => __classPrivateFieldGet(this, _Market_instances, "m", _Market_semibookEventCallback).call(this, e), getSemibookOpts("asks"));
    const bidsPromise = semibook_1.default.connect(this, "bids", (e) => __classPrivateFieldGet(this, _Market_instances, "m", _Market_semibookEventCallback).call(this, e), getSemibookOpts("bids"));
    __classPrivateFieldSet(this, _Market_asksSemibook, await asksPromise, "f");
    __classPrivateFieldSet(this, _Market_bidsSemibook, await bidsPromise, "f");
}, _Market_semibookEventCallback = async function _Market_semibookEventCallback({ cbArg, event, ethersLog: ethersLog, }) {
    for (const [cb, params] of __classPrivateFieldGet(this, _Market_subscriptions, "f")) {
        if (params.type === "once") {
            let isFilterSatisfied;
            if (!("filter" in params)) {
                isFilterSatisfied = true;
            }
            else {
                const filterResult = params.filter(cbArg, event, ethersLog);
                isFilterSatisfied =
                    typeof filterResult === "boolean"
                        ? filterResult
                        : await filterResult;
            }
            if (isFilterSatisfied) {
                __classPrivateFieldGet(this, _Market_subscriptions, "f").delete(cb);
                Promise.resolve(cb(cbArg, event, ethersLog)).then(params.ok, params.ko);
            }
        }
        else {
            cb(cbArg, event, ethersLog);
        }
    }
};
exports.default = Market;
//# sourceMappingURL=market.js.map
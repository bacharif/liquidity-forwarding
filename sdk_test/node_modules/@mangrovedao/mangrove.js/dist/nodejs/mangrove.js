"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const constants_1 = require("./constants");
const eth = __importStar(require("./eth"));
const devNode_1 = __importDefault(require("./util/devNode"));
const types_1 = require("./types");
const logger_1 = require("./util/logger");
const big_js_1 = __importDefault(require("big.js"));
// Configure big.js global constructor
big_js_1.default.DP = 20; // precision when dividing
big_js_1.default.RM = big_js_1.default.roundHalfUp; // round to nearest
const ethers = __importStar(require("ethers"));
big_js_1.default.prototype[Symbol.for("nodejs.util.inspect.custom")] =
    big_js_1.default.prototype.toString;
/* Prevent directly calling Mangrove constructor
   use Mangrove.connect to make sure the network is reached during construction */
let canConstructMangrove = false;
const unitCalculations_1 = __importDefault(require("./util/unitCalculations"));
class Mangrove {
    //TODO types in module namespace with same name as class
    constructor(params) {
        if (!canConstructMangrove) {
            throw Error("Mangrove.js must be initialized async with Mangrove.connect (constructors cannot be async)");
        }
        // must always pass a provider-equipped signer
        this.provider = params.signer.provider;
        this.signer = params.signer;
        this.network = params.network;
        this._readOnly = params.readOnly;
        this.multicallContract = types_1.typechain.Multicall2__factory.connect(Mangrove.getAddress("Multicall2", this.network.name), this.signer);
        this.address = Mangrove.getAddress("Mangrove", this.network.name);
        this.contract = types_1.typechain.Mangrove__factory.connect(this.address, this.signer);
        const readerAddress = Mangrove.getAddress("MgvReader", this.network.name);
        this.readerContract = types_1.typechain.MgvReader__factory.connect(readerAddress, this.signer);
        const cleanerAddress = Mangrove.getAddress("MgvCleaner", this.network.name);
        this.cleanerContract = types_1.typechain.MgvCleaner__factory.connect(cleanerAddress, this.signer);
        // NB: We currently use MangroveOrderEnriched instead of MangroveOrder, see https://github.com/mangrovedao/mangrove/issues/535
        const orderAddress = Mangrove.getAddress(
        // "MangroveOrder",
        "MangroveOrderEnriched", this.network.name);
        // this.orderContract = typechain.MangroveOrder__factory.connect(
        this.orderContract = types_1.typechain.MangroveOrderEnriched__factory.connect(orderAddress, this.signer);
    }
    /**
     * Creates an instance of the Mangrove Typescript object
     *
     * @param {object} [options] Optional provider options.
     *
     * @example
     * ```
     * const mgv = await require('mangrove.js').connect(options); // web browser
     * ```
     *
     * if options is a string `s`, it is considered to be {provider:s}
     * const mgv = await require('mangrove.js').connect('http://127.0.0.1:8545'); // HTTP provider
     *
     * Options:
     * * privateKey: `0x...`
     * * mnemonic: `horse battery ...`
     * * path: `m/44'/60'/0'/...`
     * * provider: url, provider object, or chain string
     *
     * @returns {Mangrove} Returns an instance mangrove.js
     */
    static async connect(options) {
        if (typeof options === "undefined") {
            options = "http://localhost:8545";
        }
        if (typeof options === "string") {
            options = { provider: options };
        }
        const { readOnly, signer } = await eth._createSigner(options); // returns a provider equipped signer
        const network = await eth.getProviderNetwork(signer.provider);
        if ("send" in signer.provider) {
            const devNode = new devNode_1.default(signer.provider);
            if (await devNode.isDevNode()) {
                await Mangrove.initAndListenToDevNode(devNode);
            }
        }
        canConstructMangrove = true;
        const mgv = new Mangrove({
            signer: signer,
            network: network,
            readOnly,
        });
        canConstructMangrove = false;
        logger_1.logger.debug("Initialize Mangrove", {
            contextInfo: "mangrove.base",
            data: (0, logger_1.logdataLimiter)({
                signer: signer,
                network: network,
                readOnly: readOnly,
            }),
        });
        return mgv;
    }
    disconnect() {
        this.provider.removeAllListeners();
        logger_1.logger.debug("Disconnect from Mangrove", {
            contextInfo: "mangrove.base",
        });
    }
    /* Instance */
    /************** */
    /* Get Market object.
       Argument of the form `{base,quote}` where each is a string.
       To set your own token, use `setDecimals` and `setAddress`.
    */
    async market(params) {
        logger_1.logger.debug("Initialize Market", {
            contextInfo: "mangrove.base",
            data: {
                base: params.base,
                quote: params.quote,
                bookOptions: params.bookOptions,
            },
        });
        return await _1.Market.connect({ ...params, mgv: this });
    }
    /** Get an OfferLogic object allowing one to monitor and set up an onchain offer logic*/
    offerLogic(logic) {
        if (ethers.utils.isAddress(logic)) {
            return new _1.OfferLogic(this, logic);
        }
        else {
            // loading a multi maker predeployed logic
            const address = Mangrove.getAddress(logic, this.network.name);
            if (address) {
                return new _1.OfferLogic(this, address);
            }
            else {
                throw Error(`Cannot find ${logic} on network ${this.network.name}`);
            }
        }
    }
    /** Get a LiquidityProvider object to enable Mangrove's signer to pass buy and sell orders*/
    async liquidityProvider(p) {
        const EOA = await this.signer.getAddress();
        if (p instanceof _1.Market) {
            return new _1.LiquidityProvider({
                mgv: this,
                eoa: EOA,
                market: p,
            });
        }
        else {
            return new _1.LiquidityProvider({
                mgv: this,
                eoa: EOA,
                market: await this.market(p),
            });
        }
    }
    /* Return MgvToken instance tied. */
    token(name, options) {
        return new _1.MgvToken(name, this, options);
    }
    /**
     * Read a contract address on the current network.
     *
     * Note that this reads from the static `Mangrove` address registry which is shared across instances of this class.
     */
    getAddress(name) {
        return Mangrove.getAddress(name, this.network.name || "mainnet");
    }
    /**
     * Set a contract address on the current network.
     *
     * Note that this writes to the static `Mangrove` address registry which is shared across instances of this class.
     */
    setAddress(name, address) {
        Mangrove.setAddress(name, address, this.network.name || "mainnet");
    }
    /** Convert public token amount to internal token representation.
     *
     * if `nameOrDecimals` is a string, it is interpreted as a token name. Otherwise
     * it is the number of decimals.
     *
     * For convenience, has a static and an instance version.
     *
     *  @example
     *  ```
     *  Mangrove.toUnits(10,"USDC") // 10e6 as ethers.BigNumber
     *  mgv.toUnits(10,6) // 10e6 as ethers.BigNumber
     *  ```
     */
    static toUnits(amount, nameOrDecimals) {
        return unitCalculations_1.default.toUnits(amount, nameOrDecimals);
    }
    toUnits(amount, nameOrDecimals) {
        return Mangrove.toUnits(amount, nameOrDecimals);
    }
    /** Convert internal token amount to public token representation.
     *
     * if `nameOrDecimals` is a string, it is interpreted as a token name. Otherwise
     * it is the number of decimals.
     *
     *  @example
     *  ```
     *  mgv.fromUnits("1e19","DAI") // 10
     *  mgv.fromUnits("1e19",18) // 10
     *  ```
     */
    fromUnits(amount, nameOrDecimals) {
        return unitCalculations_1.default.fromUnits(amount, nameOrDecimals);
    }
    /** Provision available at mangrove for address given in argument, in ethers */
    async balanceOf(address, overrides = {}) {
        const bal = await this.contract.balanceOf(address, overrides);
        return this.fromUnits(bal, 18);
    }
    fundMangrove(amount, maker, overrides = {}) {
        const _overrides = { value: this.toUnits(amount, 18), ...overrides };
        return this.contract["fund(address)"](maker, _overrides);
    }
    withdraw(amount, overrides = {}) {
        return this.contract.withdraw(this.toUnits(amount, 18), overrides);
    }
    approveMangrove(tokenName, arg = {}) {
        return this.token(tokenName).approveMangrove(arg);
    }
    /**
     * Return global Mangrove config
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    async config() {
        const config = await this.contract.configInfo(ethers.constants.AddressZero, ethers.constants.AddressZero);
        return {
            monitor: config.global.monitor,
            useOracle: config.global.useOracle,
            notify: config.global.notify,
            gasprice: config.global.gasprice.toNumber(),
            gasmax: config.global.gasmax.toNumber(),
            dead: config.global.dead,
        };
    }
    /* Static */
    /********** */
    /**
     * Read all contract addresses on the given network.
     */
    static getAllAddresses(network) {
        if (!constants_1.addresses[network]) {
            throw Error(`No addresses for network ${network}.`);
        }
        return Object.entries(Mangrove.addresses[network]);
    }
    /**
     * Read a contract address on a given network.
     */
    static getAddress(name, network) {
        if (!Mangrove.addresses[network]) {
            throw Error(`No addresses for network ${network}.`);
        }
        if (!Mangrove.addresses[network][name]) {
            throw Error(`No address for ${name} on network ${network}.`);
        }
        return Mangrove.addresses[network]?.[name];
    }
    /**
     * Set a contract address on the given network.
     */
    static setAddress(name, address, network) {
        if (!Mangrove.addresses[network]) {
            Mangrove.addresses[network] = {};
        }
        address = ethers.utils.getAddress(address);
        Mangrove.addresses[network][name] = address;
    }
    /**
     * Read decimals for `tokenName` on given network.
     * To read decimals directly onchain, use `fetchDecimals`.
     */
    static getDecimals(tokenName) {
        return _1.MgvToken.getDecimals(tokenName);
    }
    /**
     * Read displayed decimals for `tokenName`.
     */
    static getDisplayedDecimals(tokenName) {
        return constants_1.displayedDecimals[tokenName] || constants_1.defaultDisplayedDecimals;
    }
    /**
     * Read displayed decimals for `tokenName` when displayed as a price.
     */
    static getDisplayedPriceDecimals(tokenName) {
        return (constants_1.displayedPriceDecimals[tokenName] || constants_1.defaultDisplayedPriceDecimals);
    }
    /**
     * Set decimals for `tokenName` on current network.
     */
    static setDecimals(tokenName, dec) {
        _1.MgvToken.setDecimals(tokenName, dec);
    }
    /**
     * Set displayed decimals for `tokenName`.
     */
    static setDisplayedDecimals(tokenName, dec) {
        constants_1.displayedDecimals[tokenName] = dec;
    }
    /**
     * Set displayed decimals for `tokenName` when displayed as a price.
     */
    static setDisplayedPriceDecimals(tokenName, dec) {
        constants_1.displayedPriceDecimals[tokenName] = dec;
    }
    /**
     * Read chain for decimals of `tokenName` on current network and save them
     */
    static async fetchDecimals(tokenName, provider) {
        const network = await eth.getProviderNetwork(provider);
        const token = types_1.typechain.IERC20__factory.connect(Mangrove.getAddress(tokenName, network.name), provider);
        const decimals = await token.decimals();
        this.setDecimals(tokenName, decimals);
        return decimals;
    }
    /**
     * Setup dev node necessary contracts if needed, register dev Multicall2
     * address, listen to future additions (a script external to mangrove.js may
     * deploy contracts during execution).
     */
    static async initAndListenToDevNode(devNode) {
        const network = await eth.getProviderNetwork(devNode.provider);
        // set necessary code
        await devNode.setToyENSCodeIfAbsent();
        await devNode.setMulticallCodeIfAbsent();
        // register Multicall2
        Mangrove.setAddress("Multicall2", devNode.multicallAddress, network.name);
        // get currently deployed contracts & listen for future ones
        const setAddress = (name, address, decimals) => {
            Mangrove.setAddress(name, address, network.name);
            if (typeof decimals !== "undefined") {
                Mangrove.setDecimals(name, decimals);
            }
        };
        const contracts = await devNode.watchAllToyENSEntries(setAddress);
        for (const { name, address, decimals } of contracts) {
            setAddress(name, address, decimals);
        }
    }
    /**
     * Returns open markets data according to mangrove reader.
     * @param from: start at market `from`. Default 0.
     * @param maxLen: max number of markets returned. Default all.
     * @param configs: fetch market's config information. Default true.
     * @param tokenInfo: fetch token information (symbol, decimals)
     * @note If an open market has a token with no/bad decimals/symbol function, this function will revert.
     */
    async openMarketsData(params = {}) {
        // set default params
        params.from ?? (params.from = 0);
        params.maxLen ?? (params.maxLen = ethers.BigNumber.from(2).pow(256).sub(1));
        params.configs ?? (params.configs = true);
        params.tokenInfos ?? (params.tokenInfos = true);
        // read open markets and their configs off mgvReader
        const raw = await this.readerContract["openMarkets(uint256,uint256,bool)"](params.from, params.maxLen, params.configs);
        // structure data object as address => (symbol,decimals,address=>config)
        const data = {};
        raw.markets.forEach(([tkn0, tkn1], i) => {
            data[tkn0] ?? (data[tkn0] = { configs: {} });
            data[tkn1] ?? (data[tkn1] = { configs: {} });
            if (params.configs) {
                data[tkn0].configs[tkn1] = raw.configs[i].config01;
                data[tkn1].configs[tkn0] = raw.configs[i].config10;
            }
        });
        const addrs = Object.keys(data);
        //read decimals & symbol for each token using Multicall
        const ierc20 = types_1.typechain.IERC20__factory.createInterface();
        const tryDecode = (ary, fnName) => {
            return ary.forEach((returnData, i) => {
                // will raise exception if call reverted
                const decoded = ierc20.decodeFunctionResult(fnName, returnData)[0];
                data[addrs[i]][fnName] = decoded;
            });
        };
        /* Grab decimals for all contracts */
        const decimalArgs = addrs.map((addr) => {
            return { target: addr, callData: ierc20.encodeFunctionData("decimals") };
        });
        const symbolArgs = addrs.map((addr) => {
            return { target: addr, callData: ierc20.encodeFunctionData("symbol") };
        });
        const { returnData } = await this.multicallContract.callStatic.aggregate([
            ...decimalArgs,
            ...symbolArgs,
        ]);
        tryDecode(returnData.slice(0, addrs.length), "decimals");
        tryDecode(returnData.slice(addrs.length), "symbol");
        // format return value
        return raw.markets.map(([tkn0, tkn1]) => {
            const { baseSymbol } = Mangrove.toBaseQuoteByCashness(data[tkn0].symbol, data[tkn1].symbol);
            const [base, quote] = baseSymbol === data[tkn0].symbol ? [tkn0, tkn1] : [tkn1, tkn0];
            return {
                base: {
                    address: base,
                    symbol: data[base].symbol,
                    decimals: data[base].decimals,
                },
                quote: {
                    address: quote,
                    symbol: data[quote].symbol,
                    decimals: data[quote].decimals,
                },
                asksConfig: params.configs
                    ? _1.Semibook.rawLocalConfigToLocalConfig(data[base].configs[quote], data[base].decimals)
                    : undefined,
                bidsConfig: params.configs
                    ? _1.Semibook.rawLocalConfigToLocalConfig(data[quote].configs[base], data[quote].decimals)
                    : undefined,
            };
        });
    }
    /**
     * Returns open markets according to mangrove reader. Will internally update Mangrove token information.
     *
     * @param from: start at market `from` (default: 0)
     * @param maxLen: max number of markets returned (default: all)
     * @param noInit: do not initialize markets (default: false)
     * @param bookOptions: bookOptions argument to pass to every new market (default: undefined)
     */
    async openMarkets(params = {}) {
        const noInit = params.noInit ?? false;
        delete params.noInit;
        const bookOptions = params.bookOptions;
        delete params.bookOptions;
        const openMarketsData = await this.openMarketsData({
            ...params,
            tokenInfos: true,
            configs: false,
        });
        // TODO: fetch all semibook configs in one Multicall and dispatch to Semibook initializations (see openMarketsData) instead of firing multiple RPC calls.
        return Promise.all(openMarketsData.map(({ base, quote }) => {
            this.token(base.symbol, {
                address: base.address,
                decimals: base.decimals,
            });
            this.token(quote.symbol, {
                address: quote.address,
                decimals: quote.decimals,
            });
            return _1.Market.connect({
                mgv: this,
                base: base.symbol,
                quote: quote.symbol,
                bookOptions: bookOptions,
                noInit: noInit,
            });
        }));
    }
    // relative cashness of a token will determine which is base & which is quote
    // lower cashness is base, higher cashness is quote, tiebreaker is lexicographic ordering of symbol string
    setCashness(symbol, cashness) {
        constants_1.cashness[symbol] = cashness;
    }
    // cashness is "how similar to cash is a token". The cashier token is the quote.
    // toBaseQuoteByCashness orders symbols according to relative cashness.
    // Assume cashness of both to be 0 if cashness is undefined for at least one argument.
    // Ordering is lex order on cashness x (string order)
    static toBaseQuoteByCashness(symbol0, symbol1) {
        let cash0 = 0;
        let cash1 = 0;
        if (symbol0 in constants_1.cashness && symbol1 in constants_1.cashness) {
            cash0 = constants_1.cashness[symbol0];
            cash1 = constants_1.cashness[symbol1];
        }
        if (cash0 < cash1 || (cash0 === cash1 && symbol0 < symbol1)) {
            return { baseSymbol: symbol0, quoteSymbol: symbol1 };
        }
        else {
            return { baseSymbol: symbol1, quoteSymbol: symbol0 };
        }
    }
}
Mangrove.typechain = types_1.typechain;
Mangrove.addresses = constants_1.addresses;
exports.default = Mangrove;
//# sourceMappingURL=mangrove.js.map
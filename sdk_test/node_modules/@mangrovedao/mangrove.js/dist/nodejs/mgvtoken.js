"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const big_js_1 = __importDefault(require("big.js"));
const ethers = __importStar(require("ethers"));
const constants_1 = require("./constants");
const mangrove_1 = __importDefault(require("./mangrove"));
const typechain = __importStar(require("./types/typechain"));
const unitCalculations_1 = __importDefault(require("./util/unitCalculations"));
function convertToApproveArgs(arg) {
    let amount;
    let overrides;
    if (arg["amount"]) {
        amount = arg["amount"];
    }
    else if (typeof arg != "object") {
        amount = arg;
    }
    if (arg["overrides"]) {
        overrides = arg["overrides"];
    }
    else if (typeof arg === "object") {
        overrides = arg;
    }
    if (amount && overrides) {
        return { amount, overrides };
    }
    else if (amount) {
        return { amount, overrides: {} };
    }
    else if (overrides) {
        return { overrides: overrides };
    }
    else {
        return { overrides: {} };
    }
}
class MgvToken {
    constructor(name, mgv, options) {
        this.mgv = mgv;
        this.name = name;
        if (options) {
            if ("address" in options) {
                this.mgv.setAddress(name, options.address);
            }
            if ("decimals" in options) {
                mangrove_1.default.setDecimals(name, options.decimals);
            }
            if ("displayedDecimals" in options) {
                mangrove_1.default.setDisplayedDecimals(name, options.displayedDecimals);
            }
        }
        this.address = this.mgv.getAddress(this.name);
        this.decimals = mangrove_1.default.getDecimals(this.name);
        this.displayedDecimals = mangrove_1.default.getDisplayedDecimals(this.name);
        this.contract = typechain.TestToken__factory.connect(this.address, this.mgv.signer);
    }
    /**
     * Convert base/quote from internal amount to public amount.
     * Uses each token's `decimals` parameter.
     *
     * @example
     * ```
     * const usdc = mgv.token("USDC");
     * token.fromUnits("1e7") // 10
     * const dai = mgv.token("DAI")
     * market.fromUnits("1e18") // 1
     * ```
     */
    fromUnits(amount) {
        return unitCalculations_1.default.fromUnits(amount, this.decimals);
    }
    /**
     * Convert base/quote from public amount to internal contract amount.
     * Uses each token's `decimals` parameter.
     *
     * If `bq` is `"base"`, will convert the base, the quote otherwise.
     *
     * @example
     * ```
     * const usdc = mgv.token("USDC");
     * token.toUnits(10) // 10e7 as ethers.BigNumber
     * const dai = mgv.token("DAI")
     * market.toUnits(1) // 1e18 as ethers.BigNumber
     * ```
     */
    toUnits(amount) {
        return unitCalculations_1.default.toUnits(amount, this.decimals);
    }
    /**
     * Convert human-readable amounts to a string with the given
     * number of decimal places. Defaults to the token's decimals places.
     *
     * @example
     * ```
     * token.toFixed("10.123"); // "10.12"
     * token.toFixed(token.fromUnits("1e7"));
     * ```
     */
    toFixed(amount, decimals) {
        if (typeof decimals === "undefined") {
            decimals = this.displayedDecimals;
        }
        return (0, big_js_1.default)(amount).toFixed(decimals);
    }
    /**
     * Return allowance of `owner` given to `spender`.
     * If `owner` is not specified, defaults to current signer.
     * If `spender` is not specified, defaults to Mangrove instance.
     */
    async allowance(params = {}) {
        if (typeof params.owner === "undefined") {
            params.owner = await this.mgv.signer.getAddress();
        }
        if (typeof params.spender === "undefined") {
            params.spender = this.mgv.address;
        }
        const amount = await this.contract.allowance(params.owner, params.spender);
        return this.fromUnits(amount);
    }
    /**
     * Read decimals for `tokenName` on given network.
     * To read decimals directly onchain, use `fetchDecimals`.
     */
    static getDecimals(tokenName) {
        if (typeof constants_1.decimals[tokenName] !== "number") {
            throw Error(`No decimals on record for token ${tokenName}`);
        }
        return constants_1.decimals[tokenName];
    }
    /**
     * Set decimals for `tokenName` on current network.
     */
    static setDecimals(tokenName, dec) {
        constants_1.decimals[tokenName] = dec;
    }
    /**
     * Set approval for Mangrove on `amount`.
     */
    approveMangrove(arg = {}) {
        return this.approve(this.mgv.address, arg);
    }
    /**
     * Set approval for `spender` on `amount`.
     */
    approve(spender, arg = {}) {
        const args = convertToApproveArgs(arg);
        const _amount = "amount" in args
            ? this.toUnits(args.amount)
            : ethers.constants.MaxUint256;
        return this.contract.approve(spender, _amount, args.overrides);
    }
    /**
     * Returns the balance of `account`.
     */
    async balanceOf(account, overrides = {}) {
        const bal = await this.contract.balanceOf(account, overrides);
        return this.fromUnits(bal);
    }
    /**
     * Transfers `value` amount of tokens to address `to`
     */
    async transfer(to, value, overrides = {}) {
        return this.contract.transfer(to, this.toUnits(value), overrides);
    }
}
exports.default = MgvToken;
//# sourceMappingURL=mgvtoken.js.map
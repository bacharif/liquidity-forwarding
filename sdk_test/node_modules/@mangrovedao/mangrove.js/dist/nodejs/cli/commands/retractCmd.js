"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.describe = exports.aliases = exports.command = void 0;
const chalk_1 = __importDefault(require("chalk"));
const ethers_1 = __importDefault(require("ethers"));
const providers_1 = require("@ethersproject/providers");
const wallet_1 = require("@ethersproject/wallet");
const experimental_1 = require("@ethersproject/experimental");
const __1 = require("../..");
exports.command = "retract <base> <quote>";
exports.aliases = [];
exports.describe = "retracts all offers from the given market";
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
const builder = (yargs) => {
    return yargs
        .positional("base", { type: "string", demandOption: true })
        .positional("quote", { type: "string", demandOption: true })
        .option("ba", { choices: ["asks", "bids"] })
        .option("nodeUrl", { type: "string", demandOption: true })
        .option("privateKey", { type: "string", demandOption: true })
        .option("deprovision", { type: "boolean", default: false });
};
exports.builder = builder;
async function handler(argv) {
    const provider = (0, providers_1.getDefaultProvider)(argv.nodeUrl);
    const wallet = new wallet_1.Wallet(argv.privateKey, provider);
    const nonceManager = new experimental_1.NonceManager(wallet);
    const mangrove = await __1.Mangrove.connect({ signer: nonceManager });
    const market = await mangrove.market({
        base: argv.base,
        quote: argv.quote,
        bookOptions: { maxOffers: 200 },
    });
    const makerAddress = wallet.address;
    console.log(`Retracting offers from address ${makerAddress}`);
    const { asks, bids } = market.getBook();
    if (!argv.ba || argv.ba === "asks") {
        await retractAllFromOfferlist(market, "asks", asks, makerAddress, argv.deprovision);
    }
    if (!argv.ba || argv.ba === "bids") {
        await retractAllFromOfferlist(market, "bids", bids, makerAddress, argv.deprovision);
    }
    process.exit(0);
}
exports.handler = handler;
async function retractAllFromOfferlist(market, ba, semibook, makerAddress, deprovision) {
    const offerList = [...semibook];
    console.log(`Retracting from '${ba}' list...        (offer count: ${offerList.length})`);
    const { inbound_tkn, outbound_tkn } = market.getOutboundInbound(ba);
    const retractTxPromises = [];
    for (const offer of offerList) {
        if (offer.maker == makerAddress) {
            const provision = await market.mgv.contract.callStatic.retractOffer(outbound_tkn.address, inbound_tkn.address, offer.id, deprovision);
            const txPromise = market.mgv.contract
                .retractOffer(outbound_tkn.address, inbound_tkn.address, offer.id, deprovision)
                .then((tx) => tx.wait())
                .then((txReceipt) => {
                let msg = `* Offer ${chalk_1.default.gray(offer.id.toString())} retracted`;
                if (deprovision) {
                    msg += `, ${ethers_1.default.utils.formatUnits(provision, 18)} was credited to ${makerAddress} provisions (${txReceipt.gasUsed} gas used)`;
                }
                console.log(msg);
            });
            retractTxPromises.push(txPromise);
        }
    }
    await Promise.allSettled(retractTxPromises);
    console.log(`Done retracting from '${ba}' list...   (retracted count: ${retractTxPromises.length})`);
}
//# sourceMappingURL=retractCmd.js.map
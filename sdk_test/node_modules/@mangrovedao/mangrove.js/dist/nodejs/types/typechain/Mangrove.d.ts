import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "./common";
export declare type GlobalUnpackedStruct = {
    monitor: PromiseOrValue<string>;
    useOracle: PromiseOrValue<boolean>;
    notify: PromiseOrValue<boolean>;
    gasprice: PromiseOrValue<BigNumberish>;
    gasmax: PromiseOrValue<BigNumberish>;
    dead: PromiseOrValue<boolean>;
};
export declare type GlobalUnpackedStructOutput = [
    string,
    boolean,
    boolean,
    BigNumber,
    BigNumber,
    boolean
] & {
    monitor: string;
    useOracle: boolean;
    notify: boolean;
    gasprice: BigNumber;
    gasmax: BigNumber;
    dead: boolean;
};
export declare type LocalUnpackedStruct = {
    active: PromiseOrValue<boolean>;
    fee: PromiseOrValue<BigNumberish>;
    density: PromiseOrValue<BigNumberish>;
    offer_gasbase: PromiseOrValue<BigNumberish>;
    lock: PromiseOrValue<boolean>;
    best: PromiseOrValue<BigNumberish>;
    last: PromiseOrValue<BigNumberish>;
};
export declare type LocalUnpackedStructOutput = [
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    BigNumber,
    BigNumber
] & {
    active: boolean;
    fee: BigNumber;
    density: BigNumber;
    offer_gasbase: BigNumber;
    lock: boolean;
    best: BigNumber;
    last: BigNumber;
};
export declare type OfferUnpackedStruct = {
    prev: PromiseOrValue<BigNumberish>;
    next: PromiseOrValue<BigNumberish>;
    wants: PromiseOrValue<BigNumberish>;
    gives: PromiseOrValue<BigNumberish>;
};
export declare type OfferUnpackedStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
] & {
    prev: BigNumber;
    next: BigNumber;
    wants: BigNumber;
    gives: BigNumber;
};
export declare type OfferDetailUnpackedStruct = {
    maker: PromiseOrValue<string>;
    gasreq: PromiseOrValue<BigNumberish>;
    offer_gasbase: PromiseOrValue<BigNumberish>;
    gasprice: PromiseOrValue<BigNumberish>;
};
export declare type OfferDetailUnpackedStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber
] & {
    maker: string;
    gasreq: BigNumber;
    offer_gasbase: BigNumber;
    gasprice: BigNumber;
};
export declare namespace MgvLib {
    type SingleOrderStruct = {
        outbound_tkn: PromiseOrValue<string>;
        inbound_tkn: PromiseOrValue<string>;
        offerId: PromiseOrValue<BigNumberish>;
        offer: PromiseOrValue<BigNumberish>;
        wants: PromiseOrValue<BigNumberish>;
        gives: PromiseOrValue<BigNumberish>;
        offerDetail: PromiseOrValue<BigNumberish>;
        global: PromiseOrValue<BigNumberish>;
        local: PromiseOrValue<BigNumberish>;
    };
    type SingleOrderStructOutput = [
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        outbound_tkn: string;
        inbound_tkn: string;
        offerId: BigNumber;
        offer: BigNumber;
        wants: BigNumber;
        gives: BigNumber;
        offerDetail: BigNumber;
        global: BigNumber;
        local: BigNumber;
    };
}
export interface MangroveInterface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "PERMIT_TYPEHASH()": FunctionFragment;
        "activate(address,address,uint256,uint256,uint256)": FunctionFragment;
        "allowances(address,address,address,address)": FunctionFragment;
        "approve(address,address,address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "best(address,address)": FunctionFragment;
        "config(address,address)": FunctionFragment;
        "configInfo(address,address)": FunctionFragment;
        "deactivate(address,address)": FunctionFragment;
        "flashloan((address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256),address)": FunctionFragment;
        "fund(address)": FunctionFragment;
        "fund()": FunctionFragment;
        "governance()": FunctionFragment;
        "isLive(uint256)": FunctionFragment;
        "kill()": FunctionFragment;
        "locked(address,address)": FunctionFragment;
        "marketOrder(address,address,uint256,uint256,bool)": FunctionFragment;
        "marketOrderFor(address,address,uint256,uint256,bool,address)": FunctionFragment;
        "newOffer(address,address,uint256,uint256,uint256,uint256,uint256)": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "offerDetails(address,address,uint256)": FunctionFragment;
        "offerInfo(address,address,uint256)": FunctionFragment;
        "offers(address,address,uint256)": FunctionFragment;
        "permit(address,address,address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "retractOffer(address,address,uint256,bool)": FunctionFragment;
        "setDensity(address,address,uint256)": FunctionFragment;
        "setFee(address,address,uint256)": FunctionFragment;
        "setGasbase(address,address,uint256)": FunctionFragment;
        "setGasmax(uint256)": FunctionFragment;
        "setGasprice(uint256)": FunctionFragment;
        "setGovernance(address)": FunctionFragment;
        "setMonitor(address)": FunctionFragment;
        "setNotify(bool)": FunctionFragment;
        "setUseOracle(bool)": FunctionFragment;
        "snipes(address,address,uint256[4][],bool)": FunctionFragment;
        "snipesFor(address,address,uint256[4][],bool,address)": FunctionFragment;
        "updateOffer(address,address,uint256,uint256,uint256,uint256,uint256,uint256)": FunctionFragment;
        "withdraw(uint256)": FunctionFragment;
        "withdrawERC20(address,uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "PERMIT_TYPEHASH" | "activate" | "allowances" | "approve" | "balanceOf" | "best" | "config" | "configInfo" | "deactivate" | "flashloan" | "fund(address)" | "fund()" | "governance" | "isLive" | "kill" | "locked" | "marketOrder" | "marketOrderFor" | "newOffer" | "nonces" | "offerDetails" | "offerInfo" | "offers" | "permit" | "retractOffer" | "setDensity" | "setFee" | "setGasbase" | "setGasmax" | "setGasprice" | "setGovernance" | "setMonitor" | "setNotify" | "setUseOracle" | "snipes" | "snipesFor" | "updateOffer" | "withdraw" | "withdrawERC20"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "PERMIT_TYPEHASH", values?: undefined): string;
    encodeFunctionData(functionFragment: "activate", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "allowances", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>
    ]): string;
    encodeFunctionData(functionFragment: "approve", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "best", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "config", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "configInfo", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "deactivate", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "flashloan", values: [MgvLib.SingleOrderStruct, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "fund(address)", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "fund()", values?: undefined): string;
    encodeFunctionData(functionFragment: "governance", values?: undefined): string;
    encodeFunctionData(functionFragment: "isLive", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "kill", values?: undefined): string;
    encodeFunctionData(functionFragment: "locked", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "marketOrder", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "marketOrderFor", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<boolean>,
        PromiseOrValue<string>
    ]): string;
    encodeFunctionData(functionFragment: "newOffer", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "offerDetails", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "offerInfo", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "offers", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "retractOffer", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "setDensity", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "setFee", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "setGasbase", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "setGasmax", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "setGasprice", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "setGovernance", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "setMonitor", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "setNotify", values: [PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "setUseOracle", values: [PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "snipes", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        [
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ][],
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "snipesFor", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        [
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ][],
        PromiseOrValue<boolean>,
        PromiseOrValue<string>
    ]): string;
    encodeFunctionData(functionFragment: "updateOffer", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "withdraw", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "withdrawERC20", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "PERMIT_TYPEHASH", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "activate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowances", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "best", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "config", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "configInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deactivate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "flashloan", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fund(address)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fund()", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "governance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isLive", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "kill", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "locked", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "marketOrder", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "marketOrderFor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "newOffer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "offerDetails", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "offerInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "offers", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "retractOffer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setDensity", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setGasbase", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setGasmax", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setGasprice", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setGovernance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setMonitor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setNotify", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setUseOracle", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "snipes", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "snipesFor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateOffer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawERC20", data: BytesLike): Result;
    events: {
        "Approval(address,address,address,address,uint256)": EventFragment;
        "Credit(address,uint256)": EventFragment;
        "Debit(address,uint256)": EventFragment;
        "Kill()": EventFragment;
        "NewMgv()": EventFragment;
        "OfferFail(address,address,uint256,address,uint256,uint256,bytes32)": EventFragment;
        "OfferRetract(address,address,uint256)": EventFragment;
        "OfferSuccess(address,address,uint256,address,uint256,uint256)": EventFragment;
        "OfferWrite(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256)": EventFragment;
        "OrderComplete(address,address,address,uint256,uint256,uint256,uint256)": EventFragment;
        "OrderStart()": EventFragment;
        "PosthookFail(address,address,uint256,bytes32)": EventFragment;
        "SetActive(address,address,bool)": EventFragment;
        "SetDensity(address,address,uint256)": EventFragment;
        "SetFee(address,address,uint256)": EventFragment;
        "SetGasbase(address,address,uint256)": EventFragment;
        "SetGasmax(uint256)": EventFragment;
        "SetGasprice(uint256)": EventFragment;
        "SetGovernance(address)": EventFragment;
        "SetMonitor(address)": EventFragment;
        "SetNotify(bool)": EventFragment;
        "SetUseOracle(bool)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Credit"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Debit"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Kill"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NewMgv"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OfferFail"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OfferRetract"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OfferSuccess"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OfferWrite"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OrderComplete"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OrderStart"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PosthookFail"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetActive"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetDensity"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetFee"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetGasbase"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetGasmax"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetGasprice"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetGovernance"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetMonitor"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetNotify"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetUseOracle"): EventFragment;
}
export interface ApprovalEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    owner: string;
    spender: string;
    value: BigNumber;
}
export declare type ApprovalEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    BigNumber
], ApprovalEventObject>;
export declare type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;
export interface CreditEventObject {
    maker: string;
    amount: BigNumber;
}
export declare type CreditEvent = TypedEvent<[string, BigNumber], CreditEventObject>;
export declare type CreditEventFilter = TypedEventFilter<CreditEvent>;
export interface DebitEventObject {
    maker: string;
    amount: BigNumber;
}
export declare type DebitEvent = TypedEvent<[string, BigNumber], DebitEventObject>;
export declare type DebitEventFilter = TypedEventFilter<DebitEvent>;
export interface KillEventObject {
}
export declare type KillEvent = TypedEvent<[], KillEventObject>;
export declare type KillEventFilter = TypedEventFilter<KillEvent>;
export interface NewMgvEventObject {
}
export declare type NewMgvEvent = TypedEvent<[], NewMgvEventObject>;
export declare type NewMgvEventFilter = TypedEventFilter<NewMgvEvent>;
export interface OfferFailEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    id: BigNumber;
    taker: string;
    takerWants: BigNumber;
    takerGives: BigNumber;
    mgvData: string;
}
export declare type OfferFailEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    string
], OfferFailEventObject>;
export declare type OfferFailEventFilter = TypedEventFilter<OfferFailEvent>;
export interface OfferRetractEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    id: BigNumber;
}
export declare type OfferRetractEvent = TypedEvent<[
    string,
    string,
    BigNumber
], OfferRetractEventObject>;
export declare type OfferRetractEventFilter = TypedEventFilter<OfferRetractEvent>;
export interface OfferSuccessEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    id: BigNumber;
    taker: string;
    takerWants: BigNumber;
    takerGives: BigNumber;
}
export declare type OfferSuccessEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber
], OfferSuccessEventObject>;
export declare type OfferSuccessEventFilter = TypedEventFilter<OfferSuccessEvent>;
export interface OfferWriteEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    maker: string;
    wants: BigNumber;
    gives: BigNumber;
    gasprice: BigNumber;
    gasreq: BigNumber;
    id: BigNumber;
    prev: BigNumber;
}
export declare type OfferWriteEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
], OfferWriteEventObject>;
export declare type OfferWriteEventFilter = TypedEventFilter<OfferWriteEvent>;
export interface OrderCompleteEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    taker: string;
    takerGot: BigNumber;
    takerGave: BigNumber;
    penalty: BigNumber;
    feePaid: BigNumber;
}
export declare type OrderCompleteEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
], OrderCompleteEventObject>;
export declare type OrderCompleteEventFilter = TypedEventFilter<OrderCompleteEvent>;
export interface OrderStartEventObject {
}
export declare type OrderStartEvent = TypedEvent<[], OrderStartEventObject>;
export declare type OrderStartEventFilter = TypedEventFilter<OrderStartEvent>;
export interface PosthookFailEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    offerId: BigNumber;
    posthookData: string;
}
export declare type PosthookFailEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    string
], PosthookFailEventObject>;
export declare type PosthookFailEventFilter = TypedEventFilter<PosthookFailEvent>;
export interface SetActiveEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    value: boolean;
}
export declare type SetActiveEvent = TypedEvent<[
    string,
    string,
    boolean
], SetActiveEventObject>;
export declare type SetActiveEventFilter = TypedEventFilter<SetActiveEvent>;
export interface SetDensityEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    value: BigNumber;
}
export declare type SetDensityEvent = TypedEvent<[
    string,
    string,
    BigNumber
], SetDensityEventObject>;
export declare type SetDensityEventFilter = TypedEventFilter<SetDensityEvent>;
export interface SetFeeEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    value: BigNumber;
}
export declare type SetFeeEvent = TypedEvent<[
    string,
    string,
    BigNumber
], SetFeeEventObject>;
export declare type SetFeeEventFilter = TypedEventFilter<SetFeeEvent>;
export interface SetGasbaseEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    offer_gasbase: BigNumber;
}
export declare type SetGasbaseEvent = TypedEvent<[
    string,
    string,
    BigNumber
], SetGasbaseEventObject>;
export declare type SetGasbaseEventFilter = TypedEventFilter<SetGasbaseEvent>;
export interface SetGasmaxEventObject {
    value: BigNumber;
}
export declare type SetGasmaxEvent = TypedEvent<[BigNumber], SetGasmaxEventObject>;
export declare type SetGasmaxEventFilter = TypedEventFilter<SetGasmaxEvent>;
export interface SetGaspriceEventObject {
    value: BigNumber;
}
export declare type SetGaspriceEvent = TypedEvent<[BigNumber], SetGaspriceEventObject>;
export declare type SetGaspriceEventFilter = TypedEventFilter<SetGaspriceEvent>;
export interface SetGovernanceEventObject {
    value: string;
}
export declare type SetGovernanceEvent = TypedEvent<[string], SetGovernanceEventObject>;
export declare type SetGovernanceEventFilter = TypedEventFilter<SetGovernanceEvent>;
export interface SetMonitorEventObject {
    value: string;
}
export declare type SetMonitorEvent = TypedEvent<[string], SetMonitorEventObject>;
export declare type SetMonitorEventFilter = TypedEventFilter<SetMonitorEvent>;
export interface SetNotifyEventObject {
    value: boolean;
}
export declare type SetNotifyEvent = TypedEvent<[boolean], SetNotifyEventObject>;
export declare type SetNotifyEventFilter = TypedEventFilter<SetNotifyEvent>;
export interface SetUseOracleEventObject {
    value: boolean;
}
export declare type SetUseOracleEvent = TypedEvent<[boolean], SetUseOracleEventObject>;
export declare type SetUseOracleEventFilter = TypedEventFilter<SetUseOracleEvent>;
export interface Mangrove extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: MangroveInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;
        activate(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, fee: PromiseOrValue<BigNumberish>, density: PromiseOrValue<BigNumberish>, offer_gasbase: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        allowances(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<string>, arg3: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        approve(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        best(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        config(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber
        ] & {
            _global: BigNumber;
            _local: BigNumber;
        }>;
        configInfo(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            GlobalUnpackedStructOutput,
            LocalUnpackedStructOutput
        ] & {
            global: GlobalUnpackedStructOutput;
            local: LocalUnpackedStructOutput;
        }>;
        deactivate(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        flashloan(sor: MgvLib.SingleOrderStruct, taker: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "fund(address)"(maker: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "fund()"(overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        governance(overrides?: CallOverrides): Promise<[string]>;
        isLive(offer: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[boolean]>;
        kill(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        locked(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        marketOrder(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, takerWants: PromiseOrValue<BigNumberish>, takerGives: PromiseOrValue<BigNumberish>, fillWants: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        marketOrderFor(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, takerWants: PromiseOrValue<BigNumberish>, takerGives: PromiseOrValue<BigNumberish>, fillWants: PromiseOrValue<boolean>, taker: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        newOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        offerDetails(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;
        offerInfo(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[
            OfferUnpackedStructOutput,
            OfferDetailUnpackedStructOutput
        ] & {
            offer: OfferUnpackedStructOutput;
            offerDetail: OfferDetailUnpackedStructOutput;
        }>;
        offers(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;
        permit(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        retractOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, deprovision: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setDensity(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, density: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setFee(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, fee: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setGasbase(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offer_gasbase: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setGasmax(gasmax: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setGasprice(gasprice: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setGovernance(governanceAddress: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setMonitor(monitor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setNotify(notify: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setUseOracle(useOracle: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        snipes(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, targets: [
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ][], fillWants: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        snipesFor(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, targets: [
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ][], fillWants: PromiseOrValue<boolean>, taker: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        withdraw(amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        withdrawERC20(tokenAddress: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;
    activate(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, fee: PromiseOrValue<BigNumberish>, density: PromiseOrValue<BigNumberish>, offer_gasbase: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    allowances(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<string>, arg3: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    approve(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    best(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    config(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
        BigNumber,
        BigNumber
    ] & {
        _global: BigNumber;
        _local: BigNumber;
    }>;
    configInfo(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
        GlobalUnpackedStructOutput,
        LocalUnpackedStructOutput
    ] & {
        global: GlobalUnpackedStructOutput;
        local: LocalUnpackedStructOutput;
    }>;
    deactivate(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    flashloan(sor: MgvLib.SingleOrderStruct, taker: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "fund(address)"(maker: PromiseOrValue<string>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "fund()"(overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    governance(overrides?: CallOverrides): Promise<string>;
    isLive(offer: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;
    kill(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    locked(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    marketOrder(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, takerWants: PromiseOrValue<BigNumberish>, takerGives: PromiseOrValue<BigNumberish>, fillWants: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    marketOrderFor(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, takerWants: PromiseOrValue<BigNumberish>, takerGives: PromiseOrValue<BigNumberish>, fillWants: PromiseOrValue<boolean>, taker: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    newOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    offerDetails(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
    offerInfo(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[
        OfferUnpackedStructOutput,
        OfferDetailUnpackedStructOutput
    ] & {
        offer: OfferUnpackedStructOutput;
        offerDetail: OfferDetailUnpackedStructOutput;
    }>;
    offers(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
    permit(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    retractOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, deprovision: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setDensity(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, density: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setFee(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, fee: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setGasbase(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offer_gasbase: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setGasmax(gasmax: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setGasprice(gasprice: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setGovernance(governanceAddress: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setMonitor(monitor: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setNotify(notify: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setUseOracle(useOracle: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    snipes(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, targets: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ][], fillWants: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    snipesFor(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, targets: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ][], fillWants: PromiseOrValue<boolean>, taker: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    withdraw(amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    withdrawERC20(tokenAddress: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;
        activate(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, fee: PromiseOrValue<BigNumberish>, density: PromiseOrValue<BigNumberish>, offer_gasbase: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        allowances(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<string>, arg3: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        approve(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        best(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        config(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber
        ] & {
            _global: BigNumber;
            _local: BigNumber;
        }>;
        configInfo(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            GlobalUnpackedStructOutput,
            LocalUnpackedStructOutput
        ] & {
            global: GlobalUnpackedStructOutput;
            local: LocalUnpackedStructOutput;
        }>;
        deactivate(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        flashloan(sor: MgvLib.SingleOrderStruct, taker: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        "fund(address)"(maker: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        "fund()"(overrides?: CallOverrides): Promise<void>;
        governance(overrides?: CallOverrides): Promise<string>;
        isLive(offer: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;
        kill(overrides?: CallOverrides): Promise<void>;
        locked(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        marketOrder(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, takerWants: PromiseOrValue<BigNumberish>, takerGives: PromiseOrValue<BigNumberish>, fillWants: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber, BigNumber, BigNumber]>;
        marketOrderFor(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, takerWants: PromiseOrValue<BigNumberish>, takerGives: PromiseOrValue<BigNumberish>, fillWants: PromiseOrValue<boolean>, taker: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            takerGot: BigNumber;
            takerGave: BigNumber;
            bounty: BigNumber;
            feePaid: BigNumber;
        }>;
        newOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        offerDetails(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        offerInfo(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[
            OfferUnpackedStructOutput,
            OfferDetailUnpackedStructOutput
        ] & {
            offer: OfferUnpackedStructOutput;
            offerDetail: OfferDetailUnpackedStructOutput;
        }>;
        offers(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        permit(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        retractOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, deprovision: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<BigNumber>;
        setDensity(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, density: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        setFee(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, fee: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        setGasbase(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offer_gasbase: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        setGasmax(gasmax: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        setGasprice(gasprice: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        setGovernance(governanceAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        setMonitor(monitor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        setNotify(notify: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        setUseOracle(useOracle: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        snipes(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, targets: [
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ][], fillWants: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber, BigNumber, BigNumber, BigNumber]>;
        snipesFor(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, targets: [
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ][], fillWants: PromiseOrValue<boolean>, taker: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            successes: BigNumber;
            takerGot: BigNumber;
            takerGave: BigNumber;
            bounty: BigNumber;
            feePaid: BigNumber;
        }>;
        updateOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        withdraw(amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;
        withdrawERC20(tokenAddress: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "Approval(address,address,address,address,uint256)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, owner?: null, spender?: null, value?: null): ApprovalEventFilter;
        Approval(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, owner?: null, spender?: null, value?: null): ApprovalEventFilter;
        "Credit(address,uint256)"(maker?: PromiseOrValue<string> | null, amount?: null): CreditEventFilter;
        Credit(maker?: PromiseOrValue<string> | null, amount?: null): CreditEventFilter;
        "Debit(address,uint256)"(maker?: PromiseOrValue<string> | null, amount?: null): DebitEventFilter;
        Debit(maker?: PromiseOrValue<string> | null, amount?: null): DebitEventFilter;
        "Kill()"(): KillEventFilter;
        Kill(): KillEventFilter;
        "NewMgv()"(): NewMgvEventFilter;
        NewMgv(): NewMgvEventFilter;
        "OfferFail(address,address,uint256,address,uint256,uint256,bytes32)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, id?: null, taker?: null, takerWants?: null, takerGives?: null, mgvData?: null): OfferFailEventFilter;
        OfferFail(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, id?: null, taker?: null, takerWants?: null, takerGives?: null, mgvData?: null): OfferFailEventFilter;
        "OfferRetract(address,address,uint256)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, id?: null): OfferRetractEventFilter;
        OfferRetract(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, id?: null): OfferRetractEventFilter;
        "OfferSuccess(address,address,uint256,address,uint256,uint256)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, id?: null, taker?: null, takerWants?: null, takerGives?: null): OfferSuccessEventFilter;
        OfferSuccess(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, id?: null, taker?: null, takerWants?: null, takerGives?: null): OfferSuccessEventFilter;
        "OfferWrite(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, maker?: null, wants?: null, gives?: null, gasprice?: null, gasreq?: null, id?: null, prev?: null): OfferWriteEventFilter;
        OfferWrite(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, maker?: null, wants?: null, gives?: null, gasprice?: null, gasreq?: null, id?: null, prev?: null): OfferWriteEventFilter;
        "OrderComplete(address,address,address,uint256,uint256,uint256,uint256)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, taker?: PromiseOrValue<string> | null, takerGot?: null, takerGave?: null, penalty?: null, feePaid?: null): OrderCompleteEventFilter;
        OrderComplete(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, taker?: PromiseOrValue<string> | null, takerGot?: null, takerGave?: null, penalty?: null, feePaid?: null): OrderCompleteEventFilter;
        "OrderStart()"(): OrderStartEventFilter;
        OrderStart(): OrderStartEventFilter;
        "PosthookFail(address,address,uint256,bytes32)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, offerId?: null, posthookData?: null): PosthookFailEventFilter;
        PosthookFail(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, offerId?: null, posthookData?: null): PosthookFailEventFilter;
        "SetActive(address,address,bool)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, value?: null): SetActiveEventFilter;
        SetActive(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, value?: null): SetActiveEventFilter;
        "SetDensity(address,address,uint256)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, value?: null): SetDensityEventFilter;
        SetDensity(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, value?: null): SetDensityEventFilter;
        "SetFee(address,address,uint256)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, value?: null): SetFeeEventFilter;
        SetFee(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, value?: null): SetFeeEventFilter;
        "SetGasbase(address,address,uint256)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, offer_gasbase?: null): SetGasbaseEventFilter;
        SetGasbase(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, offer_gasbase?: null): SetGasbaseEventFilter;
        "SetGasmax(uint256)"(value?: null): SetGasmaxEventFilter;
        SetGasmax(value?: null): SetGasmaxEventFilter;
        "SetGasprice(uint256)"(value?: null): SetGaspriceEventFilter;
        SetGasprice(value?: null): SetGaspriceEventFilter;
        "SetGovernance(address)"(value?: null): SetGovernanceEventFilter;
        SetGovernance(value?: null): SetGovernanceEventFilter;
        "SetMonitor(address)"(value?: null): SetMonitorEventFilter;
        SetMonitor(value?: null): SetMonitorEventFilter;
        "SetNotify(bool)"(value?: null): SetNotifyEventFilter;
        SetNotify(value?: null): SetNotifyEventFilter;
        "SetUseOracle(bool)"(value?: null): SetUseOracleEventFilter;
        SetUseOracle(value?: null): SetUseOracleEventFilter;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;
        PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;
        activate(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, fee: PromiseOrValue<BigNumberish>, density: PromiseOrValue<BigNumberish>, offer_gasbase: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        allowances(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<string>, arg3: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        approve(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        best(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        config(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        configInfo(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        deactivate(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        flashloan(sor: MgvLib.SingleOrderStruct, taker: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        "fund(address)"(maker: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        "fund()"(overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        governance(overrides?: CallOverrides): Promise<BigNumber>;
        isLive(offer: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        kill(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        locked(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        marketOrder(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, takerWants: PromiseOrValue<BigNumberish>, takerGives: PromiseOrValue<BigNumberish>, fillWants: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        marketOrderFor(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, takerWants: PromiseOrValue<BigNumberish>, takerGives: PromiseOrValue<BigNumberish>, fillWants: PromiseOrValue<boolean>, taker: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        newOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        offerDetails(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        offerInfo(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        offers(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        permit(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        retractOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, deprovision: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setDensity(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, density: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setFee(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, fee: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setGasbase(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offer_gasbase: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setGasmax(gasmax: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setGasprice(gasprice: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setGovernance(governanceAddress: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setMonitor(monitor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setNotify(notify: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setUseOracle(useOracle: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        snipes(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, targets: [
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ][], fillWants: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        snipesFor(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, targets: [
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ][], fillWants: PromiseOrValue<boolean>, taker: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updateOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        withdraw(amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        withdrawERC20(tokenAddress: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        activate(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, fee: PromiseOrValue<BigNumberish>, density: PromiseOrValue<BigNumberish>, offer_gasbase: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        allowances(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<string>, arg3: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        best(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        config(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        configInfo(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        deactivate(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        flashloan(sor: MgvLib.SingleOrderStruct, taker: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "fund(address)"(maker: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "fund()"(overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isLive(offer: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        kill(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        locked(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        marketOrder(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, takerWants: PromiseOrValue<BigNumberish>, takerGives: PromiseOrValue<BigNumberish>, fillWants: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        marketOrderFor(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, takerWants: PromiseOrValue<BigNumberish>, takerGives: PromiseOrValue<BigNumberish>, fillWants: PromiseOrValue<boolean>, taker: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        newOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        offerDetails(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        offerInfo(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        offers(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        permit(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        retractOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, deprovision: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setDensity(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, density: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setFee(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, fee: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setGasbase(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offer_gasbase: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setGasmax(gasmax: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setGasprice(gasprice: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setGovernance(governanceAddress: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setMonitor(monitor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setNotify(notify: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setUseOracle(useOracle: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        snipes(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, targets: [
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ][], fillWants: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        snipesFor(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, targets: [
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>
        ][], fillWants: PromiseOrValue<boolean>, taker: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        withdraw(amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        withdrawERC20(tokenAddress: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}
//# sourceMappingURL=Mangrove.d.ts.map
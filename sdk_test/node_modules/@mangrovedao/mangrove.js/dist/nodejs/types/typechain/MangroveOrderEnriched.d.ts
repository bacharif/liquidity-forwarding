import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "./common";
export declare namespace MgvLib {
    type SingleOrderStruct = {
        outbound_tkn: PromiseOrValue<string>;
        inbound_tkn: PromiseOrValue<string>;
        offerId: PromiseOrValue<BigNumberish>;
        offer: PromiseOrValue<BigNumberish>;
        wants: PromiseOrValue<BigNumberish>;
        gives: PromiseOrValue<BigNumberish>;
        offerDetail: PromiseOrValue<BigNumberish>;
        global: PromiseOrValue<BigNumberish>;
        local: PromiseOrValue<BigNumberish>;
    };
    type SingleOrderStructOutput = [
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        outbound_tkn: string;
        inbound_tkn: string;
        offerId: BigNumber;
        offer: BigNumber;
        wants: BigNumber;
        gives: BigNumber;
        offerDetail: BigNumber;
        global: BigNumber;
        local: BigNumber;
    };
    type OrderResultStruct = {
        makerData: PromiseOrValue<BytesLike>;
        mgvData: PromiseOrValue<BytesLike>;
    };
    type OrderResultStructOutput = [string, string] & {
        makerData: string;
        mgvData: string;
    };
}
export declare namespace IOrderLogic {
    type TakerOrderStruct = {
        outbound_tkn: PromiseOrValue<string>;
        inbound_tkn: PromiseOrValue<string>;
        fillOrKill: PromiseOrValue<boolean>;
        takerWants: PromiseOrValue<BigNumberish>;
        takerGives: PromiseOrValue<BigNumberish>;
        fillWants: PromiseOrValue<boolean>;
        restingOrder: PromiseOrValue<boolean>;
        pivotId: PromiseOrValue<BigNumberish>;
        expiryDate: PromiseOrValue<BigNumberish>;
    };
    type TakerOrderStructOutput = [
        string,
        string,
        boolean,
        BigNumber,
        BigNumber,
        boolean,
        boolean,
        BigNumber,
        BigNumber
    ] & {
        outbound_tkn: string;
        inbound_tkn: string;
        fillOrKill: boolean;
        takerWants: BigNumber;
        takerGives: BigNumber;
        fillWants: boolean;
        restingOrder: boolean;
        pivotId: BigNumber;
        expiryDate: BigNumber;
    };
    type TakerOrderResultStruct = {
        takerGot: PromiseOrValue<BigNumberish>;
        takerGave: PromiseOrValue<BigNumberish>;
        bounty: PromiseOrValue<BigNumberish>;
        fee: PromiseOrValue<BigNumberish>;
        offerId: PromiseOrValue<BigNumberish>;
    };
    type TakerOrderResultStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        takerGot: BigNumber;
        takerGave: BigNumber;
        bounty: BigNumber;
        fee: BigNumber;
        offerId: BigNumber;
    };
}
export interface MangroveOrderEnrichedInterface extends utils.Interface {
    functions: {
        "MGV()": FunctionFragment;
        "NO_ROUTER()": FunctionFragment;
        "OFFER_GASREQ()": FunctionFragment;
        "activate(address[])": FunctionFragment;
        "admin()": FunctionFragment;
        "approve(address,address,uint256)": FunctionFragment;
        "checkList(address[])": FunctionFragment;
        "expiring(address,address,uint256)": FunctionFragment;
        "getMissingProvision(address,address,uint256,uint256,uint256)": FunctionFragment;
        "makerExecute((address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256))": FunctionFragment;
        "makerPosthook((address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bytes32,bytes32))": FunctionFragment;
        "offerGasreq()": FunctionFragment;
        "offerOwners(address,address,uint256[])": FunctionFragment;
        "offersOfOwner(address,address,address)": FunctionFragment;
        "ownerOf(address,address,uint256)": FunctionFragment;
        "provisionOf(address,address,uint256)": FunctionFragment;
        "reserve(address)": FunctionFragment;
        "retractOffer(address,address,uint256,bool)": FunctionFragment;
        "router()": FunctionFragment;
        "setAdmin(address)": FunctionFragment;
        "setExpiry(address,address,uint256,uint256)": FunctionFragment;
        "setRouter(address)": FunctionFragment;
        "take((address,address,bool,uint256,uint256,bool,bool,uint256,uint256))": FunctionFragment;
        "updateOffer(address,address,uint256,uint256,uint256,uint256)": FunctionFragment;
        "withdrawFromMangrove(uint256,address)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "MGV" | "NO_ROUTER" | "OFFER_GASREQ" | "activate" | "admin" | "approve" | "checkList" | "expiring" | "getMissingProvision" | "makerExecute" | "makerPosthook" | "offerGasreq" | "offerOwners" | "offersOfOwner" | "ownerOf" | "provisionOf" | "reserve" | "retractOffer" | "router" | "setAdmin" | "setExpiry" | "setRouter" | "take" | "updateOffer" | "withdrawFromMangrove"): FunctionFragment;
    encodeFunctionData(functionFragment: "MGV", values?: undefined): string;
    encodeFunctionData(functionFragment: "NO_ROUTER", values?: undefined): string;
    encodeFunctionData(functionFragment: "OFFER_GASREQ", values?: undefined): string;
    encodeFunctionData(functionFragment: "activate", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "admin", values?: undefined): string;
    encodeFunctionData(functionFragment: "approve", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "checkList", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "expiring", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "getMissingProvision", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "makerExecute", values: [MgvLib.SingleOrderStruct]): string;
    encodeFunctionData(functionFragment: "makerPosthook", values: [MgvLib.SingleOrderStruct, MgvLib.OrderResultStruct]): string;
    encodeFunctionData(functionFragment: "offerGasreq", values?: undefined): string;
    encodeFunctionData(functionFragment: "offerOwners", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>[]
    ]): string;
    encodeFunctionData(functionFragment: "offersOfOwner", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>
    ]): string;
    encodeFunctionData(functionFragment: "ownerOf", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "provisionOf", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "reserve", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "retractOffer", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "router", values?: undefined): string;
    encodeFunctionData(functionFragment: "setAdmin", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "setExpiry", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "setRouter", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "take", values: [IOrderLogic.TakerOrderStruct]): string;
    encodeFunctionData(functionFragment: "updateOffer", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "withdrawFromMangrove", values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]): string;
    decodeFunctionResult(functionFragment: "MGV", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "NO_ROUTER", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "OFFER_GASREQ", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "activate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "admin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "checkList", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "expiring", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMissingProvision", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "makerExecute", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "makerPosthook", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "offerGasreq", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "offerOwners", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "offersOfOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "ownerOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "provisionOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "reserve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "retractOffer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "router", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setExpiry", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setRouter", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "take", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateOffer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawFromMangrove", data: BytesLike): Result;
    events: {
        "LogIncident(address,address,address,uint256,bytes32,bytes32)": EventFragment;
        "NewOwnedOffer(address,address,address,uint256,address)": EventFragment;
        "OrderSummary(address,address,address,address,bool,uint256,uint256,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256)": EventFragment;
        "SetAdmin(address)": EventFragment;
        "SetExpiry(address,address,uint256,uint256)": EventFragment;
        "SetRouter(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "LogIncident"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NewOwnedOffer"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OrderSummary"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetAdmin"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetExpiry"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SetRouter"): EventFragment;
}
export interface LogIncidentEventObject {
    mangrove: string;
    outbound_tkn: string;
    inbound_tkn: string;
    offerId: BigNumber;
    makerData: string;
    mgvData: string;
}
export declare type LogIncidentEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber,
    string,
    string
], LogIncidentEventObject>;
export declare type LogIncidentEventFilter = TypedEventFilter<LogIncidentEvent>;
export interface NewOwnedOfferEventObject {
    mangrove: string;
    outbound_tkn: string;
    inbound_tkn: string;
    offerId: BigNumber;
    owner: string;
}
export declare type NewOwnedOfferEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber,
    string
], NewOwnedOfferEventObject>;
export declare type NewOwnedOfferEventFilter = TypedEventFilter<NewOwnedOfferEvent>;
export interface OrderSummaryEventObject {
    mangrove: string;
    outbound_tkn: string;
    inbound_tkn: string;
    taker: string;
    fillOrKill: boolean;
    takerWants: BigNumber;
    takerGives: BigNumber;
    fillWants: boolean;
    restingOrder: boolean;
    expiryDate: BigNumber;
    takerGot: BigNumber;
    takerGave: BigNumber;
    bounty: BigNumber;
    fee: BigNumber;
    restingOrderId: BigNumber;
}
export declare type OrderSummaryEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    boolean,
    BigNumber,
    BigNumber,
    boolean,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
], OrderSummaryEventObject>;
export declare type OrderSummaryEventFilter = TypedEventFilter<OrderSummaryEvent>;
export interface SetAdminEventObject {
    admin: string;
}
export declare type SetAdminEvent = TypedEvent<[string], SetAdminEventObject>;
export declare type SetAdminEventFilter = TypedEventFilter<SetAdminEvent>;
export interface SetExpiryEventObject {
    outbound_tkn: string;
    inbound_tkn: string;
    offerId: BigNumber;
    date: BigNumber;
}
export declare type SetExpiryEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber
], SetExpiryEventObject>;
export declare type SetExpiryEventFilter = TypedEventFilter<SetExpiryEvent>;
export interface SetRouterEventObject {
    arg0: string;
}
export declare type SetRouterEvent = TypedEvent<[string], SetRouterEventObject>;
export declare type SetRouterEventFilter = TypedEventFilter<SetRouterEvent>;
export interface MangroveOrderEnriched extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: MangroveOrderEnrichedInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        MGV(overrides?: CallOverrides): Promise<[string]>;
        NO_ROUTER(overrides?: CallOverrides): Promise<[string]>;
        OFFER_GASREQ(overrides?: CallOverrides): Promise<[BigNumber]>;
        activate(tokens: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        admin(overrides?: CallOverrides): Promise<[string]>;
        approve(token: PromiseOrValue<string>, spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        checkList(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<[void]>;
        expiring(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;
        getMissingProvision(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;
        makerExecute(order: MgvLib.SingleOrderStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        makerPosthook(order: MgvLib.SingleOrderStruct, result: MgvLib.OrderResultStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        offerGasreq(overrides?: CallOverrides): Promise<[BigNumber]>;
        offerOwners(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerIds: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<[string[]] & {
            offerOwners_: string[];
        }>;
        offersOfOwner(owner: PromiseOrValue<string>, outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            BigNumber[],
            BigNumber[]
        ] & {
            live: BigNumber[];
            dead: BigNumber[];
        }>;
        ownerOf(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string] & {
            owner: string;
        }>;
        provisionOf(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber] & {
            provision: BigNumber;
        }>;
        reserve(maker: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;
        retractOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, deprovision: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        router(overrides?: CallOverrides): Promise<[string]>;
        setAdmin(admin_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setExpiry(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, date: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setRouter(router_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        take(tko: IOrderLogic.TakerOrderStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        withdrawFromMangrove(amount: PromiseOrValue<BigNumberish>, receiver: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    MGV(overrides?: CallOverrides): Promise<string>;
    NO_ROUTER(overrides?: CallOverrides): Promise<string>;
    OFFER_GASREQ(overrides?: CallOverrides): Promise<BigNumber>;
    activate(tokens: PromiseOrValue<string>[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    admin(overrides?: CallOverrides): Promise<string>;
    approve(token: PromiseOrValue<string>, spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    checkList(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;
    expiring(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
    getMissingProvision(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
    makerExecute(order: MgvLib.SingleOrderStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    makerPosthook(order: MgvLib.SingleOrderStruct, result: MgvLib.OrderResultStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    offerGasreq(overrides?: CallOverrides): Promise<BigNumber>;
    offerOwners(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerIds: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<string[]>;
    offersOfOwner(owner: PromiseOrValue<string>, outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
        BigNumber[],
        BigNumber[]
    ] & {
        live: BigNumber[];
        dead: BigNumber[];
    }>;
    ownerOf(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;
    provisionOf(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
    reserve(maker: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
    retractOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, deprovision: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    router(overrides?: CallOverrides): Promise<string>;
    setAdmin(admin_: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setExpiry(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, date: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setRouter(router_: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    take(tko: IOrderLogic.TakerOrderStruct, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    withdrawFromMangrove(amount: PromiseOrValue<BigNumberish>, receiver: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        MGV(overrides?: CallOverrides): Promise<string>;
        NO_ROUTER(overrides?: CallOverrides): Promise<string>;
        OFFER_GASREQ(overrides?: CallOverrides): Promise<BigNumber>;
        activate(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;
        admin(overrides?: CallOverrides): Promise<string>;
        approve(token: PromiseOrValue<string>, spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;
        checkList(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;
        expiring(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        getMissingProvision(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        makerExecute(order: MgvLib.SingleOrderStruct, overrides?: CallOverrides): Promise<string>;
        makerPosthook(order: MgvLib.SingleOrderStruct, result: MgvLib.OrderResultStruct, overrides?: CallOverrides): Promise<void>;
        offerGasreq(overrides?: CallOverrides): Promise<BigNumber>;
        offerOwners(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerIds: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<string[]>;
        offersOfOwner(owner: PromiseOrValue<string>, outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            BigNumber[],
            BigNumber[]
        ] & {
            live: BigNumber[];
            dead: BigNumber[];
        }>;
        ownerOf(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;
        provisionOf(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        reserve(maker: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
        retractOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, deprovision: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<BigNumber>;
        router(overrides?: CallOverrides): Promise<string>;
        setAdmin(admin_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        setExpiry(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, date: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        setRouter(router_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        take(tko: IOrderLogic.TakerOrderStruct, overrides?: CallOverrides): Promise<IOrderLogic.TakerOrderResultStructOutput>;
        updateOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        withdrawFromMangrove(amount: PromiseOrValue<BigNumberish>, receiver: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "LogIncident(address,address,address,uint256,bytes32,bytes32)"(mangrove?: null, outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, offerId?: PromiseOrValue<BigNumberish> | null, makerData?: null, mgvData?: null): LogIncidentEventFilter;
        LogIncident(mangrove?: null, outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, offerId?: PromiseOrValue<BigNumberish> | null, makerData?: null, mgvData?: null): LogIncidentEventFilter;
        "NewOwnedOffer(address,address,address,uint256,address)"(mangrove?: null, outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, offerId?: PromiseOrValue<BigNumberish> | null, owner?: null): NewOwnedOfferEventFilter;
        NewOwnedOffer(mangrove?: null, outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, offerId?: PromiseOrValue<BigNumberish> | null, owner?: null): NewOwnedOfferEventFilter;
        "OrderSummary(address,address,address,address,bool,uint256,uint256,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256)"(mangrove?: null, outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, taker?: PromiseOrValue<string> | null, fillOrKill?: null, takerWants?: null, takerGives?: null, fillWants?: null, restingOrder?: null, expiryDate?: null, takerGot?: null, takerGave?: null, bounty?: null, fee?: null, restingOrderId?: null): OrderSummaryEventFilter;
        OrderSummary(mangrove?: null, outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, taker?: PromiseOrValue<string> | null, fillOrKill?: null, takerWants?: null, takerGives?: null, fillWants?: null, restingOrder?: null, expiryDate?: null, takerGot?: null, takerGave?: null, bounty?: null, fee?: null, restingOrderId?: null): OrderSummaryEventFilter;
        "SetAdmin(address)"(admin?: null): SetAdminEventFilter;
        SetAdmin(admin?: null): SetAdminEventFilter;
        "SetExpiry(address,address,uint256,uint256)"(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, offerId?: null, date?: null): SetExpiryEventFilter;
        SetExpiry(outbound_tkn?: PromiseOrValue<string> | null, inbound_tkn?: PromiseOrValue<string> | null, offerId?: null, date?: null): SetExpiryEventFilter;
        "SetRouter(address)"(arg0?: null): SetRouterEventFilter;
        SetRouter(arg0?: null): SetRouterEventFilter;
    };
    estimateGas: {
        MGV(overrides?: CallOverrides): Promise<BigNumber>;
        NO_ROUTER(overrides?: CallOverrides): Promise<BigNumber>;
        OFFER_GASREQ(overrides?: CallOverrides): Promise<BigNumber>;
        activate(tokens: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        admin(overrides?: CallOverrides): Promise<BigNumber>;
        approve(token: PromiseOrValue<string>, spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        checkList(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber>;
        expiring(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        getMissingProvision(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        makerExecute(order: MgvLib.SingleOrderStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        makerPosthook(order: MgvLib.SingleOrderStruct, result: MgvLib.OrderResultStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        offerGasreq(overrides?: CallOverrides): Promise<BigNumber>;
        offerOwners(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerIds: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<BigNumber>;
        offersOfOwner(owner: PromiseOrValue<string>, outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        ownerOf(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        provisionOf(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        reserve(maker: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        retractOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, deprovision: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        router(overrides?: CallOverrides): Promise<BigNumber>;
        setAdmin(admin_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setExpiry(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, date: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setRouter(router_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        take(tko: IOrderLogic.TakerOrderStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updateOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        withdrawFromMangrove(amount: PromiseOrValue<BigNumberish>, receiver: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        MGV(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        NO_ROUTER(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        OFFER_GASREQ(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        activate(tokens: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        admin(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(token: PromiseOrValue<string>, spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        checkList(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        expiring(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, arg2: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMissingProvision(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, gasreq: PromiseOrValue<BigNumberish>, gasprice: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        makerExecute(order: MgvLib.SingleOrderStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        makerPosthook(order: MgvLib.SingleOrderStruct, result: MgvLib.OrderResultStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        offerGasreq(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        offerOwners(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerIds: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        offersOfOwner(owner: PromiseOrValue<string>, outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        ownerOf(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        provisionOf(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        reserve(maker: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        retractOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, deprovision: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        router(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setAdmin(admin_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setExpiry(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, offerId: PromiseOrValue<BigNumberish>, date: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setRouter(router_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        take(tko: IOrderLogic.TakerOrderStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateOffer(outbound_tkn: PromiseOrValue<string>, inbound_tkn: PromiseOrValue<string>, wants: PromiseOrValue<BigNumberish>, gives: PromiseOrValue<BigNumberish>, pivotId: PromiseOrValue<BigNumberish>, offerId: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        withdrawFromMangrove(amount: PromiseOrValue<BigNumberish>, receiver: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}
//# sourceMappingURL=MangroveOrderEnriched.d.ts.map